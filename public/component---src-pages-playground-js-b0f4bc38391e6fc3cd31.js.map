{"version":3,"sources":["webpack:///component---src-pages-playground-js-b0f4bc38391e6fc3cd31.js","webpack:///./~/papaparse/papaparse.js","webpack:///./src/pages/playground.js"],"names":["webpackJsonp","338","module","exports","__webpack_require__","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","root","factory","apply","undefined","this","CsvToJson","_input","_config","dynamicTyping","isFunction","dynamicTypingFunction","worker","Papa","WORKERS_SUPPORTED","w","newWorker","userStep","step","userChunk","chunk","userComplete","complete","userError","error","postMessage","input","config","workerId","id","streamer","download","NetworkStreamer","StringStreamer","readable","read","on","ReadableStreamStreamer","global","File","Object","FileStreamer","stream","JsonToCsv","unpackConfig","delimiter","length","BAD_DELIMITERS","indexOf","_delimiter","quotes","Array","_quotes","newline","_newline","quoteChar","_quoteChar","header","_writeHeader","objectKeys","obj","keys","key","push","serialize","fields","data","csv","JSON","parse","hasHeader","dataKeyedByField","i","safe","row","maxCol","col","colIdx","str","toString","replace","quoteCharRegex","needsQuotes","hasAny","charAt","substrings","RegExp","meta","ChunkStreamer","replaceConfig","configCopy","copy","chunkSize","parseInt","_handle","ParserHandle","_paused","_finished","_baseIndex","_partialLine","_rowCount","_start","_nextChunk","isFirstChunk","_completeResults","errors","call","parseChunk","beforeFirstChunk","modifiedChunk","aggregate","results","paused","aborted","lastIndex","cursor","substring","finishedIncludingPreview","preview","IS_PAPA_WORKER","WORKER_ID","finished","concat","_sendError","getFileSize","xhr","contentRange","getResponseHeader","substr","lastIndexOf","RemoteChunkSize","IS_WORKER","_readChunk","_chunkLoaded","url","XMLHttpRequest","withCredentials","onload","bindFunction","onerror","_chunkError","open","downloadRequestHeaders","headers","headerName","setRequestHeader","end","send","err","message","status","readyState","responseText","errorMessage","errorText","statusText","LocalChunkSize","reader","slice","usingAsyncReader","FileReader","file","webkitSlice","mozSlice","FileReaderSync","Math","min","size","txt","readAsText","encoding","target","result","event","string","remaining","s","queue","parseOnData","_streamData","_streamEnd","_streamError","shift","_streamCleanUp","removeListener","processResults","_results","_delimiterError","addError","DefaultDelimiter","skipEmptyLines","splice","needsHeaderRow","fillHeaderFields","applyHeaderAndDynamicTyping","_fields","j","shouldApplyDynamicTyping","field","parseDynamic","value","tryParseFloat","guessDelimiter","bestDelim","bestDelta","fieldCountPrevRow","delimChoices","RECORD_SEP","UNIT_SEP","delim","delta","avgFieldCount","emptyLinesCount","Parser","fieldCount","abs","successful","bestDelimiter","guessLineEndings","r","split","n","nAppearsFirst","numWithN","val","isNumber","FLOAT","test","parseFloat","type","code","msg","_parser","self","_stepCounter","_aborted","abort","baseIndex","ignoreLastRow","delimGuess","parserConfig","pause","getCharIndex","resume","comments","fastMode","pushRow","lastCursor","finish","returnable","inputLen","stepIsFunction","doStep","saveRow","newCursor","nextNewline","stopped","linebreak","truncated","delimLen","newlineLen","commentsLen","rows","nextDelim","quoteSearch","index","getScriptPath","scripts","document","getElementsByTagName","src","LOADED_SYNC","SCRIPT_PATH","Error","workerUrl","AUTO_SCRIPT_PATH","Worker","onmessage","mainThreadReceivedMessage","workerIdCounter","workers","e","completeWorker","handle","notImplemented","terminate","workerThreadReceivedMessage","cpy","f","arguments","func","window","location","search","unparse","String","fromCharCode","BYTE_ORDER_MARK","jQuery","$","fn","options","parseNextFile","before","returned","inputElem","action","reason","fileComplete","instanceConfig","extend","userCompleteFunc","name","elem","each","idx","supported","prop","toUpperCase","attr","toLowerCase","files","body","addEventListener","prototype","create","constructor","212","_interopRequireDefault","__esModule","default","booksQuery","_react","_react2","_gatsbyLink","_styledComponents","_papaparse","_styled","_ref","books","allBooksCsv","edges","map","item","node","author","book","cover","favorite","genre","isbn","pages","createElement","Container","TitleWrapper","Title","Content"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,EAASC,GCHjC,GAAAC,GAAAC,EAAAC,GAMA,SAAAC,EAAAC,GAKAH,KAAAD,EAAA,EAAAE,EAAA,kBAAAF,KAAAK,MAAAP,EAAAG,GAAAD,IAAAM,SAAAJ,IAAAL,EAAAC,QAAAI,KAcCK,KAAA,WAED,YAsKA,SAAAC,GAAAC,EAAAC,GAEAA,OACA,IAAAC,GAAAD,EAAAC,gBAAA,CAQA,IAPAC,EAAAD,KACAD,EAAAG,sBAAAF,EAEAA,MAEAD,EAAAC,gBAEAD,EAAAI,QAAAC,EAAAC,kBACA,CACA,GAAAC,GAAAC,GAmBA,OAjBAD,GAAAE,SAAAT,EAAAU,KACAH,EAAAI,UAAAX,EAAAY,MACAL,EAAAM,aAAAb,EAAAc,SACAP,EAAAQ,UAAAf,EAAAgB,MAEAhB,EAAAU,KAAAR,EAAAF,EAAAU,MACAV,EAAAY,MAAAV,EAAAF,EAAAY,OACAZ,EAAAc,SAAAZ,EAAAF,EAAAc,UACAd,EAAAgB,MAAAd,EAAAF,EAAAgB,aACAhB,GAAAI,WAEAG,GAAAU,aACAC,MAAAnB,EACAoB,OAAAnB,EACAoB,SAAAb,EAAAc,KAMA,GAAAC,GAAA,IAeA,OAdA,gBAAAvB,GAGAuB,EADAtB,EAAAuB,SACA,GAAAC,GAAAxB,GAEA,GAAAyB,GAAAzB,GAEAD,EAAA2B,YAAA,GAAAxB,EAAAH,EAAA4B,OAAAzB,EAAAH,EAAA6B,IAEAN,EAAA,GAAAO,GAAA7B,IAEA8B,EAAAC,MAAAhC,YAAAgC,OAAAhC,YAAAiC,WACAV,EAAA,GAAAW,GAAAjC,IAEAsB,EAAAY,OAAAnC,GAQA,QAAAoC,GAAApC,EAAAC,GA8DA,QAAAoC,KAEA,gBAAApC,KAGA,gBAAAA,GAAAqC,WACA,IAAArC,EAAAqC,UAAAC,QACAjC,EAAAkC,eAAAC,QAAAxC,EAAAqC,cAAA,IAEAI,EAAAzC,EAAAqC,YAGA,iBAAArC,GAAA0C,QACA1C,EAAA0C,iBAAAC,UACAC,EAAA5C,EAAA0C,QAEA,gBAAA1C,GAAA6C,UACAC,EAAA9C,EAAA6C,SAEA,gBAAA7C,GAAA+C,YACAC,EAAAhD,EAAA+C,WAEA,iBAAA/C,GAAAiD,SACAC,EAAAlD,EAAAiD,SAKA,QAAAE,GAAAC,GAEA,mBAAAA,GACA,QACA,IAAAC,KACA,QAAAC,KAAAF,GACAC,EAAAE,KAAAD,EACA,OAAAD,GAIA,QAAAG,GAAAC,EAAAC,GAEA,GAAAC,GAAA,EAEA,iBAAAF,KACAA,EAAAG,KAAAC,MAAAJ,IACA,gBAAAC,KACAA,EAAAE,KAAAC,MAAAH,GAEA,IAAAI,GAAAL,YAAAd,QAAAc,EAAAnB,OAAA,EACAyB,IAAAL,EAAA,YAAAf,OAGA,IAAAmB,GAAAZ,EACA,CACA,OAAAc,GAAA,EAAmBA,EAAAP,EAAAnB,OAAmB0B,IAEtCA,EAAA,IACAL,GAAAlB,GACAkB,GAAAM,EAAAR,EAAAO,KAEAN,GAAApB,OAAA,IACAqB,GAAAb,GAIA,OAAAoB,GAAA,EAAoBA,EAAAR,EAAApB,OAAmB4B,IACvC,CAGA,OAFAC,GAAAL,EAAAL,EAAAnB,OAAAoB,EAAAQ,GAAA5B,OAEA8B,EAAA,EAAqBA,EAAAD,EAAcC,IACnC,CACAA,EAAA,IACAT,GAAAlB,EACA,IAAA4B,GAAAP,GAAAC,EAAAN,EAAAW,IACAT,IAAAM,EAAAP,EAAAQ,GAAAG,GAAAD,GAGAF,EAAAR,EAAApB,OAAA,IACAqB,GAAAb,GAGA,MAAAa,GAIA,QAAAM,GAAAK,EAAAF,GAEA,sBAAAE,IAAA,OAAAA,EACA,QAEAA,KAAAC,WAAAC,QAAAC,EAAAzB,IAEA,IAAA0B,GAAA,iBAAA9B,OACAA,YAAAD,QAAAC,EAAAwB,IACAO,EAAAL,EAAAjE,EAAAkC,iBACA+B,EAAA9B,QAAAC,IAAA,GACA,MAAA6B,EAAAM,OAAA,IACA,MAAAN,EAAAM,OAAAN,EAAAhC,OAAA,EAEA,OAAAoC,GAAA1B,EAAAsB,EAAAtB,EAAAsB,EAGA,QAAAK,GAAAL,EAAAO,GAEA,OAAAb,GAAA,EAAkBA,EAAAa,EAAAvC,OAAuB0B,IACzC,GAAAM,EAAA9B,QAAAqC,EAAAb,KAAA,EACA,QACA,UAvKA,GAMApB,IAAA,EAGAM,GAAA,EAGAT,EAAA,IAGAK,EAAA,OAGAE,EAAA,GAEAZ,IAEA,IAAAqC,GAAA,GAAAK,QAAA9B,EAAA,IAKA,IAHA,gBAAAjD,KACAA,EAAA6D,KAAAC,MAAA9D,IAEAA,YAAA4C,OACA,CACA,IAAA5C,EAAAuC,QAAAvC,EAAA,YAAA4C,OACA,MAAAa,GAAA,KAAAzD,EACA,oBAAAA,GAAA,GACA,MAAAyD,GAAAL,EAAApD,EAAA,IAAAA,OAEA,oBAAAA,GAmBA,MAjBA,gBAAAA,GAAA2D,OACA3D,EAAA2D,KAAAE,KAAAC,MAAA9D,EAAA2D,OAEA3D,EAAA2D,eAAAf,SAEA5C,EAAA0D,SACA1D,EAAA0D,OAAA1D,EAAAgF,MAAAhF,EAAAgF,KAAAtB,QAEA1D,EAAA0D,SACA1D,EAAA0D,OAAA1D,EAAA2D,KAAA,YAAAf,OACA5C,EAAA0D,OACAN,EAAApD,EAAA2D,KAAA,KAEA3D,EAAA2D,KAAA,YAAAf,QAAA,gBAAA5C,GAAA2D,KAAA,KACA3D,EAAA2D,MAAA3D,EAAA2D,QAGAF,EAAAzD,EAAA0D,WAAA1D,EAAA2D,SAIA,0DAmHA,QAAAsB,GAAA7D,GAkGA,QAAA8D,GAAA9D,GAGA,GAAA+D,GAAAC,EAAAhE,EACA+D,GAAAE,UAAAC,SAAAH,EAAAE,WACAjE,EAAAT,MAAAS,EAAAP,QACAsE,EAAAE,UAAA,MACAvF,KAAAyF,QAAA,GAAAC,GAAAL,GACArF,KAAAyF,QAAAhE,SAAAzB,KACAA,KAAAG,QAAAkF,EAzGArF,KAAAyF,QAAA,KACAzF,KAAA2F,SAAA,EACA3F,KAAA4F,WAAA,EACA5F,KAAAE,OAAA,KACAF,KAAA6F,WAAA,EACA7F,KAAA8F,aAAA,GACA9F,KAAA+F,UAAA,EACA/F,KAAAgG,OAAA,EACAhG,KAAAiG,WAAA,KACAjG,KAAAkG,cAAA,EACAlG,KAAAmG,kBACAtC,QACAuC,UACAlB,SAEAE,EAAAiB,KAAArG,KAAAsB,GAEAtB,KAAAsG,WAAA,SAAAvF,GAGA,GAAAf,KAAAkG,cAAA7F,EAAAL,KAAAG,QAAAoG,kBACA,CACA,GAAAC,GAAAxG,KAAAG,QAAAoG,iBAAAxF,EACAhB,UAAAyG,IACAzF,EAAAyF,GAEAxG,KAAAkG,cAAA,CAGA,IAAAO,GAAAzG,KAAA8F,aAAA/E,CACAf,MAAA8F,aAAA,EAEA,IAAAY,GAAA1G,KAAAyF,QAAAzB,MAAAyC,EAAAzG,KAAA6F,YAAA7F,KAAA4F,UAEA,KAAA5F,KAAAyF,QAAAkB,WAAA3G,KAAAyF,QAAAmB,UAAA,CAGA,GAAAC,GAAAH,EAAAxB,KAAA4B,MAEA9G,MAAA4F,YAEA5F,KAAA8F,aAAAW,EAAAM,UAAAF,EAAA7G,KAAA6F,YACA7F,KAAA6F,WAAAgB,GAGAH,KAAA7C,OACA7D,KAAA+F,WAAAW,EAAA7C,KAAApB,OAEA,IAAAuE,GAAAhH,KAAA4F,WAAA5F,KAAAG,QAAA8G,SAAAjH,KAAA+F,WAAA/F,KAAAG,QAAA8G,OAEA,IAAAC,EAEAjF,EAAAb,aACAsF,UACAnF,SAAAf,EAAA2G,UACAC,SAAAJ,QAGA,IAAA3G,EAAAL,KAAAG,QAAAY,OACA,CAEA,GADAf,KAAAG,QAAAY,MAAA2F,EAAA1G,KAAAyF,SACAzF,KAAA2F,QACA,MACAe,GAAA3G,OACAC,KAAAmG,iBAAApG,OAeA,MAZAC,MAAAG,QAAAU,MAAAb,KAAAG,QAAAY,QACAf,KAAAmG,iBAAAtC,KAAA7D,KAAAmG,iBAAAtC,KAAAwD,OAAAX,EAAA7C,MACA7D,KAAAmG,iBAAAC,OAAApG,KAAAmG,iBAAAC,OAAAiB,OAAAX,EAAAN,QACApG,KAAAmG,iBAAAjB,KAAAwB,EAAAxB,OAGA8B,IAAA3G,EAAAL,KAAAG,QAAAc,WAAAyF,KAAAxB,KAAA0B,SACA5G,KAAAG,QAAAc,SAAAjB,KAAAmG,iBAAAnG,KAAAE,QAEA8G,GAAAN,KAAAxB,KAAAyB,QACA3G,KAAAiG,aAEAS,IAGA1G,KAAAsH,WAAA,SAAAnG,GAEAd,EAAAL,KAAAG,QAAAgB,OACAnB,KAAAG,QAAAgB,SACA+F,GAAAlH,KAAAG,QAAAgB,OAEAc,EAAAb,aACAG,SAAAf,EAAA2G,UACAhG,QACAiG,UAAA,KAmBA,QAAAzF,GAAAL,GAyGA,QAAAiG,GAAAC,GAEA,GAAAC,GAAAD,EAAAE,kBAAA,gBACA,eAAAD,GACA,EAEAjC,SAAAiC,EAAAE,OAAAF,EAAAG,YAAA,SA7GAtG,QACAA,EAAAiE,YACAjE,EAAAiE,UAAA/E,EAAAqH,iBACA1C,EAAAkB,KAAArG,KAAAsB,EAEA,IAAAkG,EAEAM,GAEA9H,KAAAiG,WAAA,WAEAjG,KAAA+H,aACA/H,KAAAgI,gBAKAhI,KAAAiG,WAAA,WAEAjG,KAAA+H,cAIA/H,KAAAqC,OAAA,SAAA4F,GAEAjI,KAAAE,OAAA+H,EACAjI,KAAAiG,cAGAjG,KAAA+H,WAAA,WAEA,GAAA/H,KAAA4F,UAGA,WADA5F,MAAAgI,cAmBA,IAfAR,EAAA,GAAAU,gBAEAlI,KAAAG,QAAAgI,kBAEAX,EAAAW,gBAAAnI,KAAAG,QAAAgI,iBAGAL,IAEAN,EAAAY,OAAAC,EAAArI,KAAAgI,aAAAhI,MACAwH,EAAAc,QAAAD,EAAArI,KAAAuI,YAAAvI,OAGAwH,EAAAgB,KAAA,MAAAxI,KAAAE,QAAA4H,GAEA9H,KAAAG,QAAAsI,uBACA,CACA,GAAAC,GAAA1I,KAAAG,QAAAsI,sBAEA,QAAAE,KAAAD,GAEAlB,EAAAoB,iBAAAD,EAAAD,EAAAC,IAIA,GAAA3I,KAAAG,QAAAoF,UACA,CACA,GAAAsD,GAAA7I,KAAAgG,OAAAhG,KAAAG,QAAAoF,UAAA,CACAiC,GAAAoB,iBAAA,iBAAA5I,KAAAgG,OAAA,IAAA6C,GACArB,EAAAoB,iBAAA,mCAGA,IACApB,EAAAsB,OAEA,MAAAC,GACA/I,KAAAuI,YAAAQ,EAAAC,SAGAlB,GAAA,IAAAN,EAAAyB,OACAjJ,KAAAuI,cAEAvI,KAAAgG,QAAAhG,KAAAG,QAAAoF,WAGAvF,KAAAgI,aAAA,WAEA,MAAAR,EAAA0B,WAAA,CAGA,GAAA1B,EAAAyB,OAAA,KAAAzB,EAAAyB,QAAA,IAGA,WADAjJ,MAAAuI,aAIAvI,MAAA4F,WAAA5F,KAAAG,QAAAoF,WAAAvF,KAAAgG,OAAAuB,EAAAC,GACAxH,KAAAsG,WAAAkB,EAAA2B,gBAGAnJ,KAAAuI,YAAA,SAAAa,GAEA,GAAAC,GAAA7B,EAAA8B,YAAAF,CACApJ,MAAAsH,WAAA+B,IAgBA,QAAAjH,GAAAd,GAEAA,QACAA,EAAAiE,YACAjE,EAAAiE,UAAA/E,EAAA+I,gBACApE,EAAAkB,KAAArG,KAAAsB,EAEA,IAAAkI,GAAAC,EAIAC,EAAA,mBAAAC,WAEA3J,MAAAqC,OAAA,SAAAuH,GAEA5J,KAAAE,OAAA0J,EACAH,EAAAG,EAAAH,OAAAG,EAAAC,aAAAD,EAAAE,SAEAJ,GAEAF,EAAA,GAAAG,YACAH,EAAApB,OAAAC,EAAArI,KAAAgI,aAAAhI,MACAwJ,EAAAlB,QAAAD,EAAArI,KAAAuI,YAAAvI,OAGAwJ,EAAA,GAAAO,gBAEA/J,KAAAiG,cAGAjG,KAAAiG,WAAA,WAEAjG,KAAA4F,WAAA5F,KAAAG,QAAA8G,WAAAjH,KAAA+F,UAAA/F,KAAAG,QAAA8G,UACAjH,KAAA+H,cAGA/H,KAAA+H,WAAA,WAEA,GAAA1G,GAAArB,KAAAE,MACA,IAAAF,KAAAG,QAAAoF,UACA,CACA,GAAAsD,GAAAmB,KAAAC,IAAAjK,KAAAgG,OAAAhG,KAAAG,QAAAoF,UAAAvF,KAAAE,OAAAgK,KACA7I,GAAAoI,EAAApD,KAAAhF,EAAArB,KAAAgG,OAAA6C,GAEA,GAAAsB,GAAAX,EAAAY,WAAA/I,EAAArB,KAAAG,QAAAkK,SACAX,IACA1J,KAAAgI,cAAuBsC,QAAUC,OAAAJ,MAGjCnK,KAAAgI,aAAA,SAAAwC,GAGAxK,KAAAgG,QAAAhG,KAAAG,QAAAoF,UACAvF,KAAA4F,WAAA5F,KAAAG,QAAAoF,WAAAvF,KAAAgG,QAAAhG,KAAAE,OAAAgK,KACAlK,KAAAsG,WAAAkE,EAAAF,OAAAC,SAGAvK,KAAAuI,YAAA,WAEAvI,KAAAsH,WAAAkC,EAAArI,MAAA6H,UAQA,QAAApH,GAAAN,GAEAA,QACA6D,EAAAkB,KAAArG,KAAAsB,EAEA,IAAAmJ,GACAC,CACA1K,MAAAqC,OAAA,SAAAsI,GAIA,MAFAF,GAAAE,EACAD,EAAAC,EACA3K,KAAAiG,cAEAjG,KAAAiG,WAAA,WAEA,IAAAjG,KAAA4F,UAAA,CACA,GAAAsE,GAAAlK,KAAAG,QAAAoF,UACAxE,EAAAmJ,EAAAQ,EAAA/C,OAAA,EAAAuC,GAAAQ,CAGA,OAFAA,GAAAR,EAAAQ,EAAA/C,OAAAuC,GAAA,GACAlK,KAAA4F,WAAA8E,EACA1K,KAAAsG,WAAAvF,KAOA,QAAAiB,GAAAV,GAEAA,QAEA6D,EAAAkB,KAAArG,KAAAsB,EAEA,IAAAsJ,MACAC,GAAA,CAEA7K,MAAAqC,OAAA,SAAAA,GAEArC,KAAAE,OAAAmC,EAEArC,KAAAE,OAAA6B,GAAA,OAAA/B,KAAA8K,aACA9K,KAAAE,OAAA6B,GAAA,MAAA/B,KAAA+K,YACA/K,KAAAE,OAAA6B,GAAA,QAAA/B,KAAAgL,eAGAhL,KAAAiG,WAAA,WAEA2E,EAAAnI,OAEAzC,KAAAsG,WAAAsE,EAAAK,SAIAJ,GAAA,GAIA7K,KAAA8K,YAAAzC,EAAA,SAAAtH,GAEA,IAEA6J,EAAAlH,KAAA,gBAAA3C,OAAA2D,SAAA1E,KAAAG,QAAAkK,WAEAQ,IAEAA,GAAA,EACA7K,KAAAsG,WAAAsE,EAAAK,UAGA,MAAA9J,GAEAnB,KAAAgL,aAAA7J,KAEGnB,MAEHA,KAAAgL,aAAA3C,EAAA,SAAAlH,GAEAnB,KAAAkL,iBACAlL,KAAAsH,WAAAnG,EAAA6H,UACGhJ,MAEHA,KAAA+K,WAAA1C,EAAA,WAEArI,KAAAkL,iBACAlL,KAAA4F,WAAA,EACA5F,KAAA8K,YAAA,KACG9K,MAEHA,KAAAkL,eAAA7C,EAAA,WAEArI,KAAAE,OAAAiL,eAAA,OAAAnL,KAAA8K,aACA9K,KAAAE,OAAAiL,eAAA,MAAAnL,KAAA+K,YACA/K,KAAAE,OAAAiL,eAAA,QAAAnL,KAAAgL,eACGhL,MAOH,QAAA0F,GAAAvF,GAsHA,QAAAiL,KAQA,GANAC,GAAAC,IAEAC,EAAA,iGAA+F/K,EAAAgL,iBAAA,KAC/FF,GAAA,GAGAnL,EAAAsL,eAEA,OAAAtH,GAAA,EAAmBA,EAAAkH,EAAAxH,KAAApB,OAA0B0B,IAC7C,IAAAkH,EAAAxH,KAAAM,GAAA1B,QAAA,KAAA4I,EAAAxH,KAAAM,GAAA,IACAkH,EAAAxH,KAAA6H,OAAAvH,IAAA,EAMA,OAHAwH,MACAC,IAEAC,IAGA,QAAAF,KAEA,MAAAxL,GAAAiD,QAAA,IAAA0I,EAAArJ,OAGA,QAAAmJ,KAEA,GAAAP,EAAA,CAEA,OAAAlH,GAAA,EAAkBwH,KAAAxH,EAAAkH,EAAAxH,KAAApB,OAA8C0B,IAChE,OAAA4H,GAAA,EAAmBA,EAAAV,EAAAxH,KAAAM,GAAA1B,OAA6BsJ,IAChDD,EAAApI,KAAA2H,EAAAxH,KAAAM,GAAA4H,GACAV,GAAAxH,KAAA6H,OAAA,MAGA,QAAAM,GAAAC,GAKA,MAHA9L,GAAAG,uBAAAP,SAAAI,EAAAC,cAAA6L,KACA9L,EAAAC,cAAA6L,GAAA9L,EAAAG,sBAAA2L,KAEA9L,EAAAC,cAAA6L,IAAA9L,EAAAC,kBAAA,EAGA,QAAA8L,GAAAD,EAAAE,GAEA,MAAAH,GAAAC,GAEA,SAAAE,GAAA,SAAAA,GAEA,UAAAA,GAAA,UAAAA,GAGAC,EAAAD,GAEAA,EAGA,QAAAN,KAEA,IAAAR,IAAAlL,EAAAiD,SAAAjD,EAAAC,cACA,MAAAiL,EAEA,QAAAlH,GAAA,EAAkBA,EAAAkH,EAAAxH,KAAApB,OAA0B0B,IAC5C,CAGA,OAFAE,GAAAlE,EAAAiD,aAEA2I,EAAA,EAAmBA,EAAAV,EAAAxH,KAAAM,GAAA1B,OAA6BsJ,IAChD,CACA,GAAAE,GAAAF,EACAI,EAAAd,EAAAxH,KAAAM,GAAA4H,EAEA5L,GAAAiD,SACA6I,EAAAF,GAAAD,EAAArJ,OAAA,iBAAAqJ,EAAAC,IAEAI,EAAAD,EAAAD,EAAAE,GAEA,mBAAAF,GAEA5H,EAAA4H,GAAA5H,EAAA4H,OACA5H,EAAA4H,GAAAvI,KAAAyI,IAGA9H,EAAA4H,GAAAE,EAGAd,EAAAxH,KAAAM,GAAAE,EAEAlE,EAAAiD,SAEA2I,EAAAD,EAAArJ,OACA8I,EAAA,6DAAAO,EAAArJ,OAAA,sBAAAsJ,EAAA5H,GACA4H,EAAAD,EAAArJ,QACA8I,EAAA,2DAAAO,EAAArJ,OAAA,sBAAAsJ,EAAA5H,IAMA,MAFAhE,GAAAiD,QAAAiI,EAAAnG,OACAmG,EAAAnG,KAAAtB,OAAAkI,GACAT,EAGA,QAAAgB,GAAAhL,EAAA2B,EAAAyI,GAKA,OAFAa,GAAAC,EAAAC,EADAC,GAAA,iBAAyCjM,EAAAkM,WAAAlM,EAAAmM,UAGzCxI,EAAA,EAAkBA,EAAAsI,EAAAhK,OAAyB0B,IAC3C,CACA,GAAAyI,GAAAH,EAAAtI,GACA0I,EAAA,EAAAC,EAAA,EAAAC,EAAA,CACAP,GAAAzM,MAQA,QANAkH,GAAA,GAAA+F,IACAxK,UAAAoK,EACA5J,UACAiE,QAAA,KACKjD,MAAA3C,GAEL0K,EAAA,EAAmBA,EAAA9E,EAAApD,KAAApB,OAAyBsJ,IAE5C,GAAAN,GAAA,IAAAxE,EAAApD,KAAAkI,GAAAtJ,QAAA,IAAAwE,EAAApD,KAAAkI,GAAA,GAAAtJ,OACAsK,QADA,CAIA,GAAAE,GAAAhG,EAAApD,KAAAkI,GAAAtJ,MACAqK,IAAAG,EAEA,mBAAAT,GAKAS,EAAA,IAEAJ,GAAA7C,KAAAkD,IAAAD,EAAAT,GACAA,EAAAS,GANAT,EAAAS,EAUAhG,EAAApD,KAAApB,OAAA,IACAqK,GAAA7F,EAAApD,KAAApB,OAAAsK,IAEA,mBAAAR,IAAAM,EAAAN,IACAO,EAAA,OAEAP,EAAAM,EACAP,EAAAM,GAMA,MAFAzM,GAAAqC,UAAA8J,GAGAa,aAAAb,EACAc,cAAAd,GAIA,QAAAe,GAAAhM,GAEAA,IAAAsG,OAAA,UAEA,IAAA2F,GAAAjM,EAAAkM,MAAA,MAEAC,EAAAnM,EAAAkM,MAAA,MAEAE,EAAAD,EAAA/K,OAAA,GAAA+K,EAAA,GAAA/K,OAAA6K,EAAA,GAAA7K,MAEA,QAAA6K,EAAA7K,QAAAgL,EACA,UAGA,QADAC,GAAA,EACAvJ,EAAA,EAAkBA,EAAAmJ,EAAA7K,OAAc0B,IAEhC,OAAAmJ,EAAAnJ,GAAA,IACAuJ,GAGA,OAAAA,IAAAJ,EAAA7K,OAAA,cAGA,QAAA2J,GAAAuB,GAEA,GAAAC,GAAAC,EAAAC,KAAAH,EACA,OAAAC,GAAAG,WAAAJ,KAGA,QAAApC,GAAAyC,EAAAC,EAAAC,EAAA7J,GAEAgH,EAAAjF,OAAA1C,MACAsK,OACAC,OACAjF,QAAAkF,EACA7J,QArTA,GAIAnE,GACAiO,EAGA7C,EARAuC,EAAA,+CAEAO,EAAApO,KACAqO,EAAA,EAGA1I,GAAA,EACA2I,GAAA,EAEAxC,KACAT,GACAxH,QACAuC,UACAlB,QAGA,IAAA7E,EAAAF,EAAAU,MACA,CACA,GAAAD,GAAAT,EAAAU,IACAV,GAAAU,KAAA,SAAA6F,GAIA,GAFA2E,EAAA3E,EAEAiF,IACAP,QAEA,CAIA,GAHAA,IAGA,IAAAC,EAAAxH,KAAApB,OACA,MAEA4L,IAAA3H,EAAA7C,KAAApB,OACAtC,EAAA8G,SAAAoH,EAAAlO,EAAA8G,QACAkH,EAAAI,QAEA3N,EAAAyK,EAAA+C,KAUApO,KAAAgE,MAAA,SAAA3C,EAAAmN,EAAAC,GAMA,GAJAtO,EAAA6C,UACA7C,EAAA6C,QAAAqK,EAAAhM,IAEAiK,GAAA,EACAnL,EAAAqC,UAYAnC,EAAAF,EAAAqC,aAEArC,EAAAqC,UAAArC,EAAAqC,UAAAnB,GACAgK,EAAAnG,KAAA1C,UAAArC,EAAAqC,eAdA,CACA,GAAAkM,GAAArC,EAAAhL,EAAAlB,EAAA6C,QAAA7C,EAAAsL,eACAiD,GAAAvB,WACAhN,EAAAqC,UAAAkM,EAAAtB,eAGA9B,GAAA,EACAnL,EAAAqC,UAAAhC,EAAAgL,kBAEAH,EAAAnG,KAAA1C,UAAArC,EAAAqC,UAQA,GAAAmM,GAAArJ,EAAAnF,EAQA,OAPAA,GAAA8G,SAAA9G,EAAAiD,QACAuL,EAAA1H,UAEA/G,EAAAmB,EACA8M,EAAA,GAAAnB,GAAA2B,GACAtD,EAAA8C,EAAAnK,MAAA9D,EAAAsO,EAAAC,GACArD,IACAzF,GAAqBT,MAAQyB,QAAA,IAAiB0E,IAAiBnG,MAAQyB,QAAA,KAGvE3G,KAAA2G,OAAA,WAEA,MAAAhB,IAGA3F,KAAA4O,MAAA,WAEAjJ,GAAA,EACAwI,EAAAI,QACArO,IAAAyH,OAAAwG,EAAAU,iBAGA7O,KAAA8O,OAAA,WAEAnJ,GAAA,EACAyI,EAAA3M,SAAA6E,WAAApG,IAGAF,KAAA4G,QAAA,WAEA,MAAA0H,IAGAtO,KAAAuO,MAAA,WAEAD,GAAA,EACAH,EAAAI,QACAlD,EAAAnG,KAAA0B,SAAA,EACAvG,EAAAF,EAAAc,WACAd,EAAAc,SAAAoK,GACAnL,EAAA,IA+MA,QAAA8M,GAAA1L,GAGAA,OACA,IAAAsL,GAAAtL,EAAAkB,UACAQ,EAAA1B,EAAA0B,QACA+L,EAAAzN,EAAAyN,SACAlO,EAAAS,EAAAT,KACAoG,EAAA3F,EAAA2F,QACA+H,EAAA1N,EAAA0N,QAEA,IAAAjP,SAAAuB,EAAA4B,UACA,GAAAA,GAAA,QAEA,IAAAA,GAAA5B,EAAA4B,SASA,KALA,gBAAA0J,IACApM,EAAAkC,eAAAC,QAAAiK,IAAA,KACAA,EAAA,KAGAmC,IAAAnC,EACA,0CACAmC,MAAA,EACAA,EAAA,KACA,gBAAAA,IACAvO,EAAAkC,eAAAC,QAAAoM,IAAA,KACAA,GAAA,GAGA,MAAA/L,GAAA,MAAAA,GAAA,QAAAA,IACAA,EAAA,KAGA,IAAA8D,GAAA,EACAF,GAAA,CAEA5G,MAAAgE,MAAA,SAAA3C,EAAAmN,EAAAC,GAsMA,QAAAQ,GAAA5K,GAEAR,EAAAH,KAAAW,GACA6K,EAAApI,EAOA,QAAAqI,GAAAhD,GAEA,MAAAsC,GACAW,KACA,mBAAAjD,KACAA,EAAA9K,EAAAsG,OAAAb,IACAzC,EAAAX,KAAAyI,GACArF,EAAAuI,EACAJ,EAAA5K,GACAiL,GACAC,IACAH,KASA,QAAAI,GAAAC,GAEA3I,EAAA2I,EACAR,EAAA5K,GACAA,KACAqL,EAAArO,EAAAsB,QAAAK,EAAA8D,GAIA,QAAAsI,GAAAO,GAEA,OACA9L,OACAuC,SACAlB,MACA1C,UAAAoK,EACAgD,UAAA5M,EACA4D,UACAiJ,YAAAF,EACA7I,OAAAoI,GAAAV,GAAA,KAMA,QAAAe,KAEA1O,EAAAuO,KACAvL,KAAAuC,KA7PA,mBAAA/E,GACA,6BAIA,IAAAgO,GAAAhO,EAAAoB,OACAqN,EAAAlD,EAAAnK,OACAsN,EAAA/M,EAAAP,OACAuN,EAAAjB,EAAAtM,OACA6M,EAAAjP,EAAAQ,EAGAiG,GAAA,CACA,IAAAjD,MAAAuC,KAAA/B,KAAA6K,EAAA,CAEA,KAAA7N,EACA,MAAA+N,IAEA,IAAAJ,QAAA,GAAA3N,EAAAsB,QAAAO,MAAA,EACA,CAEA,OADA+M,GAAA5O,EAAAkM,MAAAvK,GACAmB,EAAA,EAAmBA,EAAA8L,EAAAxN,OAAiB0B,IACpC,CACA,GAAAE,GAAA4L,EAAA9L,EAEA,IADA2C,GAAAzC,EAAA5B,OACA0B,IAAA8L,EAAAxN,OAAA,EACAqE,GAAA9D,EAAAP,WACA,IAAAgM,EACA,MAAAW,IACA,KAAAL,GAAA1K,EAAAsD,OAAA,EAAAqI,KAAAjB,EAAA,CAEA,GAAAO,GAKA,GAHAzL,KACAoL,EAAA5K,EAAAkJ,MAAAX,IACA2C,IACA3I,EACA,MAAAwI,SAGAH,GAAA5K,EAAAkJ,MAAAX,GACA,IAAA3F,GAAA9C,GAAA8C,EAGA,MADApD,KAAA4F,MAAA,EAAAxC,GACAmI,GAAA,IAGA,MAAAA,KAQA,IALA,GAAAc,GAAA7O,EAAAsB,QAAAiK,EAAA9F,GACA4I,EAAArO,EAAAsB,QAAAK,EAAA8D,GACAlC,EAAA,GAAAK,QAAA/B,IAAA,OAMA,GAAA7B,EAAAyF,KAAA5D,EA4FA,GAAA6L,GAAA,IAAA1K,EAAA5B,QAAApB,EAAAsG,OAAAb,EAAAkJ,KAAAjB,EAAA,CAEA,GAAAW,KAAA,EACA,MAAAN,IACAtI,GAAA4I,EAAAK,EACAL,EAAArO,EAAAsB,QAAAK,EAAA8D,GACAoJ,EAAA7O,EAAAsB,QAAAiK,EAAA9F,OAKA,IAAAoJ,KAAA,IAAAA,EAAAR,QAAA,GAEArL,EAAAX,KAAArC,EAAA0F,UAAAD,EAAAoJ,IACApJ,EAAAoJ,EAAAJ,EACAI,EAAA7O,EAAAsB,QAAAiK,EAAA9F,OAJA,CASA,GAAA4I,KAAA,EAkBA,KAbA,IAHArL,EAAAX,KAAArC,EAAA0F,UAAAD,EAAA4I,IACAF,EAAAE,EAAAK,GAEAT,IAEAC,IACA3I,GACA,MAAAwI,IAGA,IAAAnI,GAAApD,EAAApB,QAAAwE,EACA,MAAAmI,IAAA,OA7HA,CAGA,GAAAe,GAAArJ,CAKA,KAFAA,MAGA,CAEA,GAAAqJ,GAAA9O,EAAAsB,QAAAO,EAAAiN,EAAA,EAGA,IAAAA,KAAA,EAYA,MAVA1B,IAEArI,EAAA1C,MACAsK,KAAA,SACAC,KAAA,gBACAjF,QAAA,4BACA3E,IAAAR,EAAApB,OACA2N,MAAAtJ,IAGAqI,GAIA,IAAAgB,IAAAd,EAAA,EACA,CACA,GAAAlD,GAAA9K,EAAA0F,UAAAD,EAAAqJ,GAAAxL,QAAAC,EAAA1B,EACA,OAAAiM,GAAAhD,GAIA,GAAA9K,EAAA8O,EAAA,KAAAjN,EAAA,CAOA,GAAA7B,EAAA8O,EAAA,KAAAvD,EACA,CACAvI,EAAAX,KAAArC,EAAA0F,UAAAD,EAAAqJ,GAAAxL,QAAAC,EAAA1B,IACA4D,EAAAqJ,EAAA,EAAAL,EACAI,EAAA7O,EAAAsB,QAAAiK,EAAA9F,GACA4I,EAAArO,EAAAsB,QAAAK,EAAA8D,EACA,OAIA,GAAAzF,EAAAsG,OAAAwI,EAAA,EAAAJ,KAAA/M,EACA,CAKA,GAJAqB,EAAAX,KAAArC,EAAA0F,UAAAD,EAAAqJ,GAAAxL,QAAAC,EAAA1B,IACAsM,EAAAW,EAAA,EAAAJ,GACAG,EAAA7O,EAAAsB,QAAAiK,EAAA9F,GAEAwI,IAEAC,IACA3I,GACA,MAAAwI,IAGA,IAAAnI,GAAApD,EAAApB,QAAAwE,EACA,MAAAmI,IAAA,EAEA,OAKAhJ,EAAA1C,MACAsK,KAAA,SACAC,KAAA,gBACAjF,QAAA,8CACA3E,IAAAR,EAAApB,OACA2N,MAAAtJ,IAGAqJ,QA5CAA,MA+FA,MAAAhB,MAkEAnP,KAAAuO,MAAA,WAEA3H,GAAA,GAIA5G,KAAA6O,aAAA,WAEA,MAAA/H,IAOA,QAAAuJ,KAEA,GAAAC,GAAAC,SAAAC,qBAAA,SACA,OAAAF,GAAA7N,OAAA6N,IAAA7N,OAAA,GAAAgO,IAAA,GAGA,QAAA9P,KAEA,IAAAH,EAAAC,kBACA,QACA,KAAAiQ,GAAA,OAAAlQ,EAAAmQ,YACA,SAAAC,OACA,sIAGA,IAAAC,GAAArQ,EAAAmQ,aAAAG,CAEAD,OAAAlO,QAAA,+BACA,IAAAjC,GAAA,GAAAuB,GAAA8O,OAAAF,EAIA,OAHAnQ,GAAAsQ,UAAAC,EACAvQ,EAAAc,GAAA0P,IACAC,EAAAzQ,EAAAc,IAAAd,EACAA,EAIA,QAAAuQ,GAAAG,GAEA,GAAAlD,GAAAkD,EAAAvN,KACAtD,EAAA4Q,EAAAjD,EAAA3M,UACAqF,GAAA,CAEA,IAAAsH,EAAA/M,MACAZ,EAAAW,UAAAgN,EAAA/M,MAAA+M,EAAAtE,UACA,IAAAsE,EAAAxH,SAAAwH,EAAAxH,QAAA7C,KACA,CACA,GAAA0K,GAAA,WACA3H,GAAA,EACAyK,EAAAnD,EAAA3M,UAAkCsC,QAAAuC,UAAAlB,MAA8B0B,SAAA,MAGhE0K,GACA/C,QACAK,MAAA2C,EACAzC,OAAAyC,EAGA,IAAAlR,EAAAE,EAAAK,UACA,CACA,OAAAuD,GAAA,EAAmBA,EAAA+J,EAAAxH,QAAA7C,KAAApB,SAEnBlC,EAAAK,UACAiD,MAAAqK,EAAAxH,QAAA7C,KAAAM,IACAiC,OAAA8H,EAAAxH,QAAAN,OACAlB,KAAAgJ,EAAAxH,QAAAxB,MACMoM,IACN1K,GAPgDzC,WAUhD+J,GAAAxH,YAEArG,GAAAE,EAAAO,aAEAP,EAAAO,UAAAoN,EAAAxH,QAAA4K,EAAApD,EAAAtE,YACAsE,GAAAxH,SAIAwH,EAAA9G,WAAAR,GACAyK,EAAAnD,EAAA3M,SAAA2M,EAAAxH,SAGA,QAAA2K,GAAA9P,EAAAmF,GACA,GAAAnG,GAAA4Q,EAAA5P,EACAlB,GAAAE,EAAAS,eACAT,EAAAS,aAAA0F,GACAnG,EAAAiR,kBACAL,GAAA5P,GAGA,QAAAgQ,KACA,wBAIA,QAAAE,GAAAL,GAEA,GAAAlD,GAAAkD,EAAAvN,IAKA,IAHA,mBAAArD,GAAA2G,WAAA+G,IACA1N,EAAA2G,UAAA+G,EAAA3M,UAEA,gBAAA2M,GAAA7M,MAEAY,EAAAb,aACAG,SAAAf,EAAA2G,UACAT,QAAAlG,EAAAwD,MAAAkK,EAAA7M,MAAA6M,EAAA5M,QACA8F,UAAA,QAGA,IAAAnF,EAAAC,MAAAgM,EAAA7M,gBAAAa,OAAAgM,EAAA7M,gBAAAc,QACA,CACA,GAAAuE,GAAAlG,EAAAwD,MAAAkK,EAAA7M,MAAA6M,EAAA5M,OACAoF,IACAzE,EAAAb,aACAG,SAAAf,EAAA2G,UACAT,UACAU,UAAA,KAMA,QAAA9B,GAAA/B,GAEA,mBAAAA,GACA,MAAAA,EACA,IAAAmO,GAAAnO,YAAAT,YACA,QAAAW,KAAAF,GACAmO,EAAAjO,GAAA6B,EAAA/B,EAAAE,GACA,OAAAiO,GAGA,QAAArJ,GAAAsJ,EAAAvD,GAEA,kBAAqBuD,EAAA7R,MAAAsO,EAAAwD,YAGrB,QAAAvR,GAAAwR,GAEA,wBAAAA,GAxhDA,GAgBAf,GAhBA7O,EAAA,WAKA,yBAAAmM,MAAoCA,KACpC,mBAAA0D,QAAsCA,OACtC,mBAAA7P,GAAsCA,QAOtC6F,GAAA7F,EAAAsO,YAAAtO,EAAAb,YACA8F,EAAAY,GAAA,0BAAAgG,KAAA7L,EAAA8P,SAAAC,QACAtB,GAAA,EACAS,KAAiBD,EAAA,EAEjB1Q,IAyBA,IAvBAA,EAAAwD,MAAA/D,EACAO,EAAAyR,QAAA3P,EAEA9B,EAAAkM,WAAAwF,OAAAC,aAAA,IACA3R,EAAAmM,SAAAuF,OAAAC,aAAA,IACA3R,EAAA4R,gBAAA,SACA5R,EAAAkC,gBAAA,cAAAlC,EAAA4R,iBACA5R,EAAAC,mBAAAqH,KAAA7F,EAAA8O,OACAvQ,EAAAmQ,YAAA,KAGAnQ,EAAA+I,eAAA,SACA/I,EAAAqH,gBAAA,QACArH,EAAAgL,iBAAA,IAGAhL,EAAAwM,SACAxM,EAAAkF,eACAlF,EAAAmB,kBACAnB,EAAA4B,eACA5B,EAAAoB,iBACApB,EAAAwB,yBAEAC,EAAAoQ,OACA,CACA,GAAAC,GAAArQ,EAAAoQ,MACAC,GAAAC,GAAAvO,MAAA,SAAAwO,GA4BA,QAAAC,KAEA,OAAA7H,EAAAnI,OAIA,YAFApC,EAAAmS,EAAAvR,WACAuR,EAAAvR,WAIA,IAAA0Q,GAAA/G,EAAA,EAEA,IAAAvK,EAAAmS,EAAAE,QACA,CACA,GAAAC,GAAAH,EAAAE,OAAAf,EAAA/H,KAAA+H,EAAAiB,UAEA,oBAAAD,GACA,CACA,aAAAA,EAAAE,OAGA,WADA1R,GAAA,aAAAwQ,EAAA/H,KAAA+H,EAAAiB,UAAAD,EAAAG,OAGA,aAAAH,EAAAE,OAGA,WADAE,IAGA,iBAAAJ,GAAArR,SACAqQ,EAAAqB,eAAAV,EAAAW,OAAAtB,EAAAqB,eAAAL,EAAArR,aAEA,aAAAqR,EAGA,WADAI,KAMA,GAAAG,GAAAvB,EAAAqB,eAAA/R,QACA0Q,GAAAqB,eAAA/R,SAAA,SAAAyF,GAEArG,EAAA6S,IACAA,EAAAxM,EAAAiL,EAAA/H,KAAA+H,EAAAiB,WACAG,KAGAvS,EAAAwD,MAAA2N,EAAA/H,KAAA+H,EAAAqB,gBAGA,QAAA7R,GAAAgS,EAAAvJ,EAAAwJ,EAAAN,GAEAzS,EAAAmS,EAAArR,QACAqR,EAAArR,OAAoBgS,QAAWvJ,EAAAwJ,EAAAN,GAG/B,QAAAC,KAEAnI,EAAAc,OAAA,KACA+G,IApFA,GAAAnR,GAAAkR,EAAAlR,WACAsJ,IAsBA,OApBA5K,MAAAqT,KAAA,SAAAC,GAEA,GAAAC,GAAA,UAAAjB,EAAAtS,MAAAwT,KAAA,WAAAC,eACA,SAAAnB,EAAAtS,MAAA0T,KAAA,QAAAC,eACA1R,EAAA0H,UAEA,KAAA4J,IAAAvT,KAAA4T,OAAA,IAAA5T,KAAA4T,MAAAnR,OACA,QAEA,QAAA0B,GAAA,EAAmBA,EAAAnE,KAAA4T,MAAAnR,OAAuB0B,IAE1CyG,EAAAlH,MACAkG,KAAA5J,KAAA4T,MAAAzP,GACAyO,UAAA5S,KACAgT,eAAAV,EAAAW,UAAiC3R,OAKjCmR,IACAzS,MAm9CA,MAh5CAkH,GAEAjF,EAAA+O,UAAAS,EAEAjR,EAAAC,oBAEAqQ,EAAAT,IAGAE,SAAAsD,KAOAtD,SAAAuD,iBAAA,8BACApD,GAAA,IACI,GANJA,GAAA,GAudA/O,EAAAoS,UAAA5R,OAAA6R,OAAA7O,EAAA4O,WACApS,EAAAoS,UAAAE,YAAAtS,EAkEAS,EAAA2R,UAAA5R,OAAA6R,OAAA7O,EAAA4O,WACA3R,EAAA2R,UAAAE,YAAA7R,EA0BAR,EAAAmS,UAAA5R,OAAA6R,OAAApS,EAAAmS,WACAnS,EAAAmS,UAAAE,YAAArS,EAuEAI,EAAA+R,UAAA5R,OAAA6R,OAAA7O,EAAA4O,WACA/R,EAAA+R,UAAAE,YAAAjS,EAswBAxB,KDWM0T,IACA,SAAU5U,EAAQC,EAASC,GAEhC,YAuBA,SAAS2U,GAAuB5Q,GAAO,MAAOA,IAAOA,EAAI6Q,WAAa7Q,GAAQ8Q,QAAS9Q,GArBvFhE,EAAQ6U,YAAa,EACrB7U,EAAQ+U,WAAavU,MEzkDtB,IAAAwU,GAAA/U,EAAA,GF6kDKgV,EAAUL,EAAuBI,GE5kDtCE,EAAAjV,EAAA,IACAkV,GF+kDoBP,EAAuBM,GE/kD3CjV,EAAA,KACAmV,GFklD0BR,EAAuBO,GEllDjDlV,EAAA,MAEAoV,GFolDmBT,EAAuBQ,GEplD1CnV,EAAA,IF0lDCD,GAAQ8U,QExlDM,SAAAQ,GAAc,GAAXhR,GAAWgR,EAAXhR,KACDiR,EAAUjR,EAAKkR,YAAtBC,KAESF,GAAMG,IAAI,SAAAC,GACzB,GAAMC,GAAOD,EAAKC,IAClB,QACEC,OAAQD,EAAKC,OACbC,KAAMF,EAAKE,KACXC,MAAOH,EAAKG,MACZC,SAA0C,SAAhCJ,EAAKI,SAAS5B,cACxB6B,MAAOL,EAAKK,MAAMjI,MAAM,KACxBkI,KAAMjQ,SAAS2P,EAAKM,KAAM,IAC1BC,MAAOlQ,SAAS2P,EAAKO,MAAO,MAIhC,OACElB,GAAAH,QAAAsB,cAAAf,EAAAgB,UAAA,KACEpB,EAAAH,QAAAsB,cAAAf,EAAAiB,aAAA,KACErB,EAAAH,QAAAsB,cAAAf,EAAAkB,MAAA,mBACAtB,EAAAH,QAAAsB,cAAA,OAAKnU,GAAG,WAEVgT,EAAAH,QAAAsB,cAAAf,EAAAmB,QAAA,OAMOzB","file":"component---src-pages-playground-js-b0f4bc38391e6fc3cd31.js","sourcesContent":["webpackJsonp([272379572042316],{\n\n/***/ 338:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n\t\tPapa Parse\n\t\tv4.3.7\n\t\thttps://github.com/mholt/PapaParse\n\t\tLicense: MIT\n\t*/\n\t(function(root, factory)\n\t{\n\t\tif (true)\n\t\t{\n\t\t\t// AMD. Register as an anonymous module.\n\t\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t\t}\n\t\telse if (typeof module === 'object' && typeof exports !== 'undefined')\n\t\t{\n\t\t\t// Node. Does not work with strict CommonJS, but\n\t\t\t// only CommonJS-like environments that support module.exports,\n\t\t\t// like Node.\n\t\t\tmodule.exports = factory();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Browser globals (root is window)\n\t\t\troot.Papa = factory();\n\t\t}\n\t}(this, function()\n\t{\n\t\t'use strict';\n\t\n\t\tvar global = (function () {\n\t\t\t// alternative method, similar to `Function('return this')()`\n\t\t\t// but without using `eval` (which is disabled when\n\t\t\t// using Content Security Policy).\n\t\n\t\t\tif (typeof self !== 'undefined') { return self; }\n\t\t\tif (typeof window !== 'undefined') { return window; }\n\t\t\tif (typeof global !== 'undefined') { return global; }\n\t\n\t\t\t// When running tests none of the above have been defined\n\t\t\treturn {};\n\t\t})();\n\t\n\t\n\t\tvar IS_WORKER = !global.document && !!global.postMessage,\n\t\t\tIS_PAPA_WORKER = IS_WORKER && /(\\?|&)papaworker(=|&|$)/.test(global.location.search),\n\t\t\tLOADED_SYNC = false, AUTO_SCRIPT_PATH;\n\t\tvar workers = {}, workerIdCounter = 0;\n\t\n\t\tvar Papa = {};\n\t\n\t\tPapa.parse = CsvToJson;\n\t\tPapa.unparse = JsonToCsv;\n\t\n\t\tPapa.RECORD_SEP = String.fromCharCode(30);\n\t\tPapa.UNIT_SEP = String.fromCharCode(31);\n\t\tPapa.BYTE_ORDER_MARK = '\\ufeff';\n\t\tPapa.BAD_DELIMITERS = ['\\r', '\\n', '\"', Papa.BYTE_ORDER_MARK];\n\t\tPapa.WORKERS_SUPPORTED = !IS_WORKER && !!global.Worker;\n\t\tPapa.SCRIPT_PATH = null;\t// Must be set by your code if you use workers and this lib is loaded asynchronously\n\t\n\t\t// Configurable chunk sizes for local and remote files, respectively\n\t\tPapa.LocalChunkSize = 1024 * 1024 * 10;\t// 10 MB\n\t\tPapa.RemoteChunkSize = 1024 * 1024 * 5;\t// 5 MB\n\t\tPapa.DefaultDelimiter = ',';\t\t\t// Used if not specified and detection fails\n\t\n\t\t// Exposed for testing and development only\n\t\tPapa.Parser = Parser;\n\t\tPapa.ParserHandle = ParserHandle;\n\t\tPapa.NetworkStreamer = NetworkStreamer;\n\t\tPapa.FileStreamer = FileStreamer;\n\t\tPapa.StringStreamer = StringStreamer;\n\t\tPapa.ReadableStreamStreamer = ReadableStreamStreamer;\n\t\n\t\tif (global.jQuery)\n\t\t{\n\t\t\tvar $ = global.jQuery;\n\t\t\t$.fn.parse = function(options)\n\t\t\t{\n\t\t\t\tvar config = options.config || {};\n\t\t\t\tvar queue = [];\n\t\n\t\t\t\tthis.each(function(idx)\n\t\t\t\t{\n\t\t\t\t\tvar supported = $(this).prop('tagName').toUpperCase() === 'INPUT'\n\t\t\t\t\t\t\t\t\t&& $(this).attr('type').toLowerCase() === 'file'\n\t\t\t\t\t\t\t\t\t&& global.FileReader;\n\t\n\t\t\t\t\tif (!supported || !this.files || this.files.length === 0)\n\t\t\t\t\t\treturn true;\t// continue to next input element\n\t\n\t\t\t\t\tfor (var i = 0; i < this.files.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tqueue.push({\n\t\t\t\t\t\t\tfile: this.files[i],\n\t\t\t\t\t\t\tinputElem: this,\n\t\t\t\t\t\t\tinstanceConfig: $.extend({}, config)\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\n\t\t\t\tparseNextFile();\t// begin parsing\n\t\t\t\treturn this;\t\t// maintains chainability\n\t\n\t\n\t\t\t\tfunction parseNextFile()\n\t\t\t\t{\n\t\t\t\t\tif (queue.length === 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (isFunction(options.complete))\n\t\t\t\t\t\t\toptions.complete();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar f = queue[0];\n\t\n\t\t\t\t\tif (isFunction(options.before))\n\t\t\t\t\t{\n\t\t\t\t\t\tvar returned = options.before(f.file, f.inputElem);\n\t\n\t\t\t\t\t\tif (typeof returned === 'object')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (returned.action === 'abort')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\terror('AbortError', f.file, f.inputElem, returned.reason);\n\t\t\t\t\t\t\t\treturn;\t// Aborts all queued files immediately\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (returned.action === 'skip')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfileComplete();\t// parse the next file in the queue, if any\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (typeof returned.config === 'object')\n\t\t\t\t\t\t\t\tf.instanceConfig = $.extend(f.instanceConfig, returned.config);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (returned === 'skip')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfileComplete();\t// parse the next file in the queue, if any\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Wrap up the user's complete callback, if any, so that ours also gets executed\n\t\t\t\t\tvar userCompleteFunc = f.instanceConfig.complete;\n\t\t\t\t\tf.instanceConfig.complete = function(results)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (isFunction(userCompleteFunc))\n\t\t\t\t\t\t\tuserCompleteFunc(results, f.file, f.inputElem);\n\t\t\t\t\t\tfileComplete();\n\t\t\t\t\t};\n\t\n\t\t\t\t\tPapa.parse(f.file, f.instanceConfig);\n\t\t\t\t}\n\t\n\t\t\t\tfunction error(name, file, elem, reason)\n\t\t\t\t{\n\t\t\t\t\tif (isFunction(options.error))\n\t\t\t\t\t\toptions.error({name: name}, file, elem, reason);\n\t\t\t\t}\n\t\n\t\t\t\tfunction fileComplete()\n\t\t\t\t{\n\t\t\t\t\tqueue.splice(0, 1);\n\t\t\t\t\tparseNextFile();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\n\t\tif (IS_PAPA_WORKER)\n\t\t{\n\t\t\tglobal.onmessage = workerThreadReceivedMessage;\n\t\t}\n\t\telse if (Papa.WORKERS_SUPPORTED)\n\t\t{\n\t\t\tAUTO_SCRIPT_PATH = getScriptPath();\n\t\n\t\t\t// Check if the script was loaded synchronously\n\t\t\tif (!document.body)\n\t\t\t{\n\t\t\t\t// Body doesn't exist yet, must be synchronous\n\t\t\t\tLOADED_SYNC = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdocument.addEventListener('DOMContentLoaded', function () {\n\t\t\t\t\tLOADED_SYNC = true;\n\t\t\t\t}, true);\n\t\t\t}\n\t\t}\n\t\n\t\n\t\n\t\n\t\tfunction CsvToJson(_input, _config)\n\t\t{\n\t\t\t_config = _config || {};\n\t\t\tvar dynamicTyping = _config.dynamicTyping || false;\n\t\t\tif (isFunction(dynamicTyping)) {\n\t\t\t\t_config.dynamicTypingFunction = dynamicTyping;\n\t\t\t\t// Will be filled on first row call\n\t\t\t\tdynamicTyping = {};\n\t\t\t}\n\t\t\t_config.dynamicTyping = dynamicTyping;\n\t\n\t\t\tif (_config.worker && Papa.WORKERS_SUPPORTED)\n\t\t\t{\n\t\t\t\tvar w = newWorker();\n\t\n\t\t\t\tw.userStep = _config.step;\n\t\t\t\tw.userChunk = _config.chunk;\n\t\t\t\tw.userComplete = _config.complete;\n\t\t\t\tw.userError = _config.error;\n\t\n\t\t\t\t_config.step = isFunction(_config.step);\n\t\t\t\t_config.chunk = isFunction(_config.chunk);\n\t\t\t\t_config.complete = isFunction(_config.complete);\n\t\t\t\t_config.error = isFunction(_config.error);\n\t\t\t\tdelete _config.worker;\t// prevent infinite loop\n\t\n\t\t\t\tw.postMessage({\n\t\t\t\t\tinput: _input,\n\t\t\t\t\tconfig: _config,\n\t\t\t\t\tworkerId: w.id\n\t\t\t\t});\n\t\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tvar streamer = null;\n\t\t\tif (typeof _input === 'string')\n\t\t\t{\n\t\t\t\tif (_config.download)\n\t\t\t\t\tstreamer = new NetworkStreamer(_config);\n\t\t\t\telse\n\t\t\t\t\tstreamer = new StringStreamer(_config);\n\t\t\t}\n\t\t\telse if (_input.readable === true && isFunction(_input.read) && isFunction(_input.on))\n\t\t\t{\n\t\t\t\tstreamer = new ReadableStreamStreamer(_config);\n\t\t\t}\n\t\t\telse if ((global.File && _input instanceof File) || _input instanceof Object)\t// ...Safari. (see issue #106)\n\t\t\t\tstreamer = new FileStreamer(_config);\n\t\n\t\t\treturn streamer.stream(_input);\n\t\t}\n\t\n\t\n\t\n\t\n\t\n\t\n\t\tfunction JsonToCsv(_input, _config)\n\t\t{\n\t\t\tvar _output = '';\n\t\t\tvar _fields = [];\n\t\n\t\t\t// Default configuration\n\t\n\t\t\t/** whether to surround every datum with quotes */\n\t\t\tvar _quotes = false;\n\t\n\t\t\t/** whether to write headers */\n\t\t\tvar _writeHeader = true;\n\t\n\t\t\t/** delimiting character */\n\t\t\tvar _delimiter = ',';\n\t\n\t\t\t/** newline character(s) */\n\t\t\tvar _newline = '\\r\\n';\n\t\n\t\t\t/** quote character */\n\t\t\tvar _quoteChar = '\"';\n\t\n\t\t\tunpackConfig();\n\t\n\t\t\tvar quoteCharRegex = new RegExp(_quoteChar, 'g');\n\t\n\t\t\tif (typeof _input === 'string')\n\t\t\t\t_input = JSON.parse(_input);\n\t\n\t\t\tif (_input instanceof Array)\n\t\t\t{\n\t\t\t\tif (!_input.length || _input[0] instanceof Array)\n\t\t\t\t\treturn serialize(null, _input);\n\t\t\t\telse if (typeof _input[0] === 'object')\n\t\t\t\t\treturn serialize(objectKeys(_input[0]), _input);\n\t\t\t}\n\t\t\telse if (typeof _input === 'object')\n\t\t\t{\n\t\t\t\tif (typeof _input.data === 'string')\n\t\t\t\t\t_input.data = JSON.parse(_input.data);\n\t\n\t\t\t\tif (_input.data instanceof Array)\n\t\t\t\t{\n\t\t\t\t\tif (!_input.fields)\n\t\t\t\t\t\t_input.fields =  _input.meta && _input.meta.fields;\n\t\n\t\t\t\t\tif (!_input.fields)\n\t\t\t\t\t\t_input.fields =  _input.data[0] instanceof Array\n\t\t\t\t\t\t\t\t\t\t? _input.fields\n\t\t\t\t\t\t\t\t\t\t: objectKeys(_input.data[0]);\n\t\n\t\t\t\t\tif (!(_input.data[0] instanceof Array) && typeof _input.data[0] !== 'object')\n\t\t\t\t\t\t_input.data = [_input.data];\t// handles input like [1,2,3] or ['asdf']\n\t\t\t\t}\n\t\n\t\t\t\treturn serialize(_input.fields || [], _input.data || []);\n\t\t\t}\n\t\n\t\t\t// Default (any valid paths should return before this)\n\t\t\tthrow 'exception: Unable to serialize unrecognized input';\n\t\n\t\n\t\t\tfunction unpackConfig()\n\t\t\t{\n\t\t\t\tif (typeof _config !== 'object')\n\t\t\t\t\treturn;\n\t\n\t\t\t\tif (typeof _config.delimiter === 'string'\n\t\t\t\t\t&& _config.delimiter.length === 1\n\t\t\t\t\t&& Papa.BAD_DELIMITERS.indexOf(_config.delimiter) === -1)\n\t\t\t\t{\n\t\t\t\t\t_delimiter = _config.delimiter;\n\t\t\t\t}\n\t\n\t\t\t\tif (typeof _config.quotes === 'boolean'\n\t\t\t\t\t|| _config.quotes instanceof Array)\n\t\t\t\t\t_quotes = _config.quotes;\n\t\n\t\t\t\tif (typeof _config.newline === 'string')\n\t\t\t\t\t_newline = _config.newline;\n\t\n\t\t\t\tif (typeof _config.quoteChar === 'string')\n\t\t\t\t\t_quoteChar = _config.quoteChar;\n\t\n\t\t\t\tif (typeof _config.header === 'boolean')\n\t\t\t\t\t_writeHeader = _config.header;\n\t\t\t}\n\t\n\t\n\t\t\t/** Turns an object's keys into an array */\n\t\t\tfunction objectKeys(obj)\n\t\t\t{\n\t\t\t\tif (typeof obj !== 'object')\n\t\t\t\t\treturn [];\n\t\t\t\tvar keys = [];\n\t\t\t\tfor (var key in obj)\n\t\t\t\t\tkeys.push(key);\n\t\t\t\treturn keys;\n\t\t\t}\n\t\n\t\t\t/** The double for loop that iterates the data and writes out a CSV string including header row */\n\t\t\tfunction serialize(fields, data)\n\t\t\t{\n\t\t\t\tvar csv = '';\n\t\n\t\t\t\tif (typeof fields === 'string')\n\t\t\t\t\tfields = JSON.parse(fields);\n\t\t\t\tif (typeof data === 'string')\n\t\t\t\t\tdata = JSON.parse(data);\n\t\n\t\t\t\tvar hasHeader = fields instanceof Array && fields.length > 0;\n\t\t\t\tvar dataKeyedByField = !(data[0] instanceof Array);\n\t\n\t\t\t\t// If there a header row, write it first\n\t\t\t\tif (hasHeader && _writeHeader)\n\t\t\t\t{\n\t\t\t\t\tfor (var i = 0; i < fields.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (i > 0)\n\t\t\t\t\t\t\tcsv += _delimiter;\n\t\t\t\t\t\tcsv += safe(fields[i], i);\n\t\t\t\t\t}\n\t\t\t\t\tif (data.length > 0)\n\t\t\t\t\t\tcsv += _newline;\n\t\t\t\t}\n\t\n\t\t\t\t// Then write out the data\n\t\t\t\tfor (var row = 0; row < data.length; row++)\n\t\t\t\t{\n\t\t\t\t\tvar maxCol = hasHeader ? fields.length : data[row].length;\n\t\n\t\t\t\t\tfor (var col = 0; col < maxCol; col++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (col > 0)\n\t\t\t\t\t\t\tcsv += _delimiter;\n\t\t\t\t\t\tvar colIdx = hasHeader && dataKeyedByField ? fields[col] : col;\n\t\t\t\t\t\tcsv += safe(data[row][colIdx], col);\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (row < data.length - 1)\n\t\t\t\t\t\tcsv += _newline;\n\t\t\t\t}\n\t\n\t\t\t\treturn csv;\n\t\t\t}\n\t\n\t\t\t/** Encloses a value around quotes if needed (makes a value safe for CSV insertion) */\n\t\t\tfunction safe(str, col)\n\t\t\t{\n\t\t\t\tif (typeof str === 'undefined' || str === null)\n\t\t\t\t\treturn '';\n\t\n\t\t\t\tstr = str.toString().replace(quoteCharRegex, _quoteChar+_quoteChar);\n\t\n\t\t\t\tvar needsQuotes = (typeof _quotes === 'boolean' && _quotes)\n\t\t\t\t\t\t\t\t|| (_quotes instanceof Array && _quotes[col])\n\t\t\t\t\t\t\t\t|| hasAny(str, Papa.BAD_DELIMITERS)\n\t\t\t\t\t\t\t\t|| str.indexOf(_delimiter) > -1\n\t\t\t\t\t\t\t\t|| str.charAt(0) === ' '\n\t\t\t\t\t\t\t\t|| str.charAt(str.length - 1) === ' ';\n\t\n\t\t\t\treturn needsQuotes ? _quoteChar + str + _quoteChar : str;\n\t\t\t}\n\t\n\t\t\tfunction hasAny(str, substrings)\n\t\t\t{\n\t\t\t\tfor (var i = 0; i < substrings.length; i++)\n\t\t\t\t\tif (str.indexOf(substrings[i]) > -1)\n\t\t\t\t\t\treturn true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\n\t\t/** ChunkStreamer is the base prototype for various streamer implementations. */\n\t\tfunction ChunkStreamer(config)\n\t\t{\n\t\t\tthis._handle = null;\n\t\t\tthis._paused = false;\n\t\t\tthis._finished = false;\n\t\t\tthis._input = null;\n\t\t\tthis._baseIndex = 0;\n\t\t\tthis._partialLine = '';\n\t\t\tthis._rowCount = 0;\n\t\t\tthis._start = 0;\n\t\t\tthis._nextChunk = null;\n\t\t\tthis.isFirstChunk = true;\n\t\t\tthis._completeResults = {\n\t\t\t\tdata: [],\n\t\t\t\terrors: [],\n\t\t\t\tmeta: {}\n\t\t\t};\n\t\t\treplaceConfig.call(this, config);\n\t\n\t\t\tthis.parseChunk = function(chunk)\n\t\t\t{\n\t\t\t\t// First chunk pre-processing\n\t\t\t\tif (this.isFirstChunk && isFunction(this._config.beforeFirstChunk))\n\t\t\t\t{\n\t\t\t\t\tvar modifiedChunk = this._config.beforeFirstChunk(chunk);\n\t\t\t\t\tif (modifiedChunk !== undefined)\n\t\t\t\t\t\tchunk = modifiedChunk;\n\t\t\t\t}\n\t\t\t\tthis.isFirstChunk = false;\n\t\n\t\t\t\t// Rejoin the line we likely just split in two by chunking the file\n\t\t\t\tvar aggregate = this._partialLine + chunk;\n\t\t\t\tthis._partialLine = '';\n\t\n\t\t\t\tvar results = this._handle.parse(aggregate, this._baseIndex, !this._finished);\n\t\n\t\t\t\tif (this._handle.paused() || this._handle.aborted())\n\t\t\t\t\treturn;\n\t\n\t\t\t\tvar lastIndex = results.meta.cursor;\n\t\n\t\t\t\tif (!this._finished)\n\t\t\t\t{\n\t\t\t\t\tthis._partialLine = aggregate.substring(lastIndex - this._baseIndex);\n\t\t\t\t\tthis._baseIndex = lastIndex;\n\t\t\t\t}\n\t\n\t\t\t\tif (results && results.data)\n\t\t\t\t\tthis._rowCount += results.data.length;\n\t\n\t\t\t\tvar finishedIncludingPreview = this._finished || (this._config.preview && this._rowCount >= this._config.preview);\n\t\n\t\t\t\tif (IS_PAPA_WORKER)\n\t\t\t\t{\n\t\t\t\t\tglobal.postMessage({\n\t\t\t\t\t\tresults: results,\n\t\t\t\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\t\t\t\tfinished: finishedIncludingPreview\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse if (isFunction(this._config.chunk))\n\t\t\t\t{\n\t\t\t\t\tthis._config.chunk(results, this._handle);\n\t\t\t\t\tif (this._paused)\n\t\t\t\t\t\treturn;\n\t\t\t\t\tresults = undefined;\n\t\t\t\t\tthis._completeResults = undefined;\n\t\t\t\t}\n\t\n\t\t\t\tif (!this._config.step && !this._config.chunk) {\n\t\t\t\t\tthis._completeResults.data = this._completeResults.data.concat(results.data);\n\t\t\t\t\tthis._completeResults.errors = this._completeResults.errors.concat(results.errors);\n\t\t\t\t\tthis._completeResults.meta = results.meta;\n\t\t\t\t}\n\t\n\t\t\t\tif (finishedIncludingPreview && isFunction(this._config.complete) && (!results || !results.meta.aborted))\n\t\t\t\t\tthis._config.complete(this._completeResults, this._input);\n\t\n\t\t\t\tif (!finishedIncludingPreview && (!results || !results.meta.paused))\n\t\t\t\t\tthis._nextChunk();\n\t\n\t\t\t\treturn results;\n\t\t\t};\n\t\n\t\t\tthis._sendError = function(error)\n\t\t\t{\n\t\t\t\tif (isFunction(this._config.error))\n\t\t\t\t\tthis._config.error(error);\n\t\t\t\telse if (IS_PAPA_WORKER && this._config.error)\n\t\t\t\t{\n\t\t\t\t\tglobal.postMessage({\n\t\t\t\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\t\t\t\terror: error,\n\t\t\t\t\t\tfinished: false\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tfunction replaceConfig(config)\n\t\t\t{\n\t\t\t\t// Deep-copy the config so we can edit it\n\t\t\t\tvar configCopy = copy(config);\n\t\t\t\tconfigCopy.chunkSize = parseInt(configCopy.chunkSize);\t// parseInt VERY important so we don't concatenate strings!\n\t\t\t\tif (!config.step && !config.chunk)\n\t\t\t\t\tconfigCopy.chunkSize = null;  // disable Range header if not streaming; bad values break IIS - see issue #196\n\t\t\t\tthis._handle = new ParserHandle(configCopy);\n\t\t\t\tthis._handle.streamer = this;\n\t\t\t\tthis._config = configCopy;\t// persist the copy to the caller\n\t\t\t}\n\t\t}\n\t\n\t\n\t\tfunction NetworkStreamer(config)\n\t\t{\n\t\t\tconfig = config || {};\n\t\t\tif (!config.chunkSize)\n\t\t\t\tconfig.chunkSize = Papa.RemoteChunkSize;\n\t\t\tChunkStreamer.call(this, config);\n\t\n\t\t\tvar xhr;\n\t\n\t\t\tif (IS_WORKER)\n\t\t\t{\n\t\t\t\tthis._nextChunk = function()\n\t\t\t\t{\n\t\t\t\t\tthis._readChunk();\n\t\t\t\t\tthis._chunkLoaded();\n\t\t\t\t};\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis._nextChunk = function()\n\t\t\t\t{\n\t\t\t\t\tthis._readChunk();\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\tthis.stream = function(url)\n\t\t\t{\n\t\t\t\tthis._input = url;\n\t\t\t\tthis._nextChunk();\t// Starts streaming\n\t\t\t};\n\t\n\t\t\tthis._readChunk = function()\n\t\t\t{\n\t\t\t\tif (this._finished)\n\t\t\t\t{\n\t\t\t\t\tthis._chunkLoaded();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\txhr = new XMLHttpRequest();\n\t\n\t\t\t\tif (this._config.withCredentials)\n\t\t\t\t{\n\t\t\t\t\txhr.withCredentials = this._config.withCredentials;\n\t\t\t\t}\n\t\n\t\t\t\tif (!IS_WORKER)\n\t\t\t\t{\n\t\t\t\t\txhr.onload = bindFunction(this._chunkLoaded, this);\n\t\t\t\t\txhr.onerror = bindFunction(this._chunkError, this);\n\t\t\t\t}\n\t\n\t\t\t\txhr.open('GET', this._input, !IS_WORKER);\n\t\t\t\t// Headers can only be set when once the request state is OPENED\n\t\t\t\tif (this._config.downloadRequestHeaders)\n\t\t\t\t{\n\t\t\t\t\tvar headers = this._config.downloadRequestHeaders;\n\t\n\t\t\t\t\tfor (var headerName in headers)\n\t\t\t\t\t{\n\t\t\t\t\t\txhr.setRequestHeader(headerName, headers[headerName]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tif (this._config.chunkSize)\n\t\t\t\t{\n\t\t\t\t\tvar end = this._start + this._config.chunkSize - 1;\t// minus one because byte range is inclusive\n\t\t\t\t\txhr.setRequestHeader('Range', 'bytes='+this._start+'-'+end);\n\t\t\t\t\txhr.setRequestHeader('If-None-Match', 'webkit-no-cache'); // https://bugs.webkit.org/show_bug.cgi?id=82672\n\t\t\t\t}\n\t\n\t\t\t\ttry {\n\t\t\t\t\txhr.send();\n\t\t\t\t}\n\t\t\t\tcatch (err) {\n\t\t\t\t\tthis._chunkError(err.message);\n\t\t\t\t}\n\t\n\t\t\t\tif (IS_WORKER && xhr.status === 0)\n\t\t\t\t\tthis._chunkError();\n\t\t\t\telse\n\t\t\t\t\tthis._start += this._config.chunkSize;\n\t\t\t}\n\t\n\t\t\tthis._chunkLoaded = function()\n\t\t\t{\n\t\t\t\tif (xhr.readyState != 4)\n\t\t\t\t\treturn;\n\t\n\t\t\t\tif (xhr.status < 200 || xhr.status >= 400)\n\t\t\t\t{\n\t\t\t\t\tthis._chunkError();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tthis._finished = !this._config.chunkSize || this._start > getFileSize(xhr);\n\t\t\t\tthis.parseChunk(xhr.responseText);\n\t\t\t}\n\t\n\t\t\tthis._chunkError = function(errorMessage)\n\t\t\t{\n\t\t\t\tvar errorText = xhr.statusText || errorMessage;\n\t\t\t\tthis._sendError(errorText);\n\t\t\t}\n\t\n\t\t\tfunction getFileSize(xhr)\n\t\t\t{\n\t\t\t\tvar contentRange = xhr.getResponseHeader('Content-Range');\n\t\t\t\tif (contentRange === null) { // no content range, then finish!\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\treturn parseInt(contentRange.substr(contentRange.lastIndexOf('/') + 1));\n\t\t\t}\n\t\t}\n\t\tNetworkStreamer.prototype = Object.create(ChunkStreamer.prototype);\n\t\tNetworkStreamer.prototype.constructor = NetworkStreamer;\n\t\n\t\n\t\tfunction FileStreamer(config)\n\t\t{\n\t\t\tconfig = config || {};\n\t\t\tif (!config.chunkSize)\n\t\t\t\tconfig.chunkSize = Papa.LocalChunkSize;\n\t\t\tChunkStreamer.call(this, config);\n\t\n\t\t\tvar reader, slice;\n\t\n\t\t\t// FileReader is better than FileReaderSync (even in worker) - see http://stackoverflow.com/q/24708649/1048862\n\t\t\t// But Firefox is a pill, too - see issue #76: https://github.com/mholt/PapaParse/issues/76\n\t\t\tvar usingAsyncReader = typeof FileReader !== 'undefined';\t// Safari doesn't consider it a function - see issue #105\n\t\n\t\t\tthis.stream = function(file)\n\t\t\t{\n\t\t\t\tthis._input = file;\n\t\t\t\tslice = file.slice || file.webkitSlice || file.mozSlice;\n\t\n\t\t\t\tif (usingAsyncReader)\n\t\t\t\t{\n\t\t\t\t\treader = new FileReader();\t\t// Preferred method of reading files, even in workers\n\t\t\t\t\treader.onload = bindFunction(this._chunkLoaded, this);\n\t\t\t\t\treader.onerror = bindFunction(this._chunkError, this);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\treader = new FileReaderSync();\t// Hack for running in a web worker in Firefox\n\t\n\t\t\t\tthis._nextChunk();\t// Starts streaming\n\t\t\t};\n\t\n\t\t\tthis._nextChunk = function()\n\t\t\t{\n\t\t\t\tif (!this._finished && (!this._config.preview || this._rowCount < this._config.preview))\n\t\t\t\t\tthis._readChunk();\n\t\t\t}\n\t\n\t\t\tthis._readChunk = function()\n\t\t\t{\n\t\t\t\tvar input = this._input;\n\t\t\t\tif (this._config.chunkSize)\n\t\t\t\t{\n\t\t\t\t\tvar end = Math.min(this._start + this._config.chunkSize, this._input.size);\n\t\t\t\t\tinput = slice.call(input, this._start, end);\n\t\t\t\t}\n\t\t\t\tvar txt = reader.readAsText(input, this._config.encoding);\n\t\t\t\tif (!usingAsyncReader)\n\t\t\t\t\tthis._chunkLoaded({ target: { result: txt } });\t// mimic the async signature\n\t\t\t}\n\t\n\t\t\tthis._chunkLoaded = function(event)\n\t\t\t{\n\t\t\t\t// Very important to increment start each time before handling results\n\t\t\t\tthis._start += this._config.chunkSize;\n\t\t\t\tthis._finished = !this._config.chunkSize || this._start >= this._input.size;\n\t\t\t\tthis.parseChunk(event.target.result);\n\t\t\t}\n\t\n\t\t\tthis._chunkError = function()\n\t\t\t{\n\t\t\t\tthis._sendError(reader.error.message);\n\t\t\t}\n\t\n\t\t}\n\t\tFileStreamer.prototype = Object.create(ChunkStreamer.prototype);\n\t\tFileStreamer.prototype.constructor = FileStreamer;\n\t\n\t\n\t\tfunction StringStreamer(config)\n\t\t{\n\t\t\tconfig = config || {};\n\t\t\tChunkStreamer.call(this, config);\n\t\n\t\t\tvar string;\n\t\t\tvar remaining;\n\t\t\tthis.stream = function(s)\n\t\t\t{\n\t\t\t\tstring = s;\n\t\t\t\tremaining = s;\n\t\t\t\treturn this._nextChunk();\n\t\t\t}\n\t\t\tthis._nextChunk = function()\n\t\t\t{\n\t\t\t\tif (this._finished) return;\n\t\t\t\tvar size = this._config.chunkSize;\n\t\t\t\tvar chunk = size ? remaining.substr(0, size) : remaining;\n\t\t\t\tremaining = size ? remaining.substr(size) : '';\n\t\t\t\tthis._finished = !remaining;\n\t\t\t\treturn this.parseChunk(chunk);\n\t\t\t}\n\t\t}\n\t\tStringStreamer.prototype = Object.create(StringStreamer.prototype);\n\t\tStringStreamer.prototype.constructor = StringStreamer;\n\t\n\t\n\t\tfunction ReadableStreamStreamer(config)\n\t\t{\n\t\t\tconfig = config || {};\n\t\n\t\t\tChunkStreamer.call(this, config);\n\t\n\t\t\tvar queue = [];\n\t\t\tvar parseOnData = true;\n\t\n\t\t\tthis.stream = function(stream)\n\t\t\t{\n\t\t\t\tthis._input = stream;\n\t\n\t\t\t\tthis._input.on('data', this._streamData);\n\t\t\t\tthis._input.on('end', this._streamEnd);\n\t\t\t\tthis._input.on('error', this._streamError);\n\t\t\t}\n\t\n\t\t\tthis._nextChunk = function()\n\t\t\t{\n\t\t\t\tif (queue.length)\n\t\t\t\t{\n\t\t\t\t\tthis.parseChunk(queue.shift());\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tparseOnData = true;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tthis._streamData = bindFunction(function(chunk)\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tqueue.push(typeof chunk === 'string' ? chunk : chunk.toString(this._config.encoding));\n\t\n\t\t\t\t\tif (parseOnData)\n\t\t\t\t\t{\n\t\t\t\t\t\tparseOnData = false;\n\t\t\t\t\t\tthis.parseChunk(queue.shift());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (error)\n\t\t\t\t{\n\t\t\t\t\tthis._streamError(error);\n\t\t\t\t}\n\t\t\t}, this);\n\t\n\t\t\tthis._streamError = bindFunction(function(error)\n\t\t\t{\n\t\t\t\tthis._streamCleanUp();\n\t\t\t\tthis._sendError(error.message);\n\t\t\t}, this);\n\t\n\t\t\tthis._streamEnd = bindFunction(function()\n\t\t\t{\n\t\t\t\tthis._streamCleanUp();\n\t\t\t\tthis._finished = true;\n\t\t\t\tthis._streamData('');\n\t\t\t}, this);\n\t\n\t\t\tthis._streamCleanUp = bindFunction(function()\n\t\t\t{\n\t\t\t\tthis._input.removeListener('data', this._streamData);\n\t\t\t\tthis._input.removeListener('end', this._streamEnd);\n\t\t\t\tthis._input.removeListener('error', this._streamError);\n\t\t\t}, this);\n\t\t}\n\t\tReadableStreamStreamer.prototype = Object.create(ChunkStreamer.prototype);\n\t\tReadableStreamStreamer.prototype.constructor = ReadableStreamStreamer;\n\t\n\t\n\t\t// Use one ParserHandle per entire CSV file or string\n\t\tfunction ParserHandle(_config)\n\t\t{\n\t\t\t// One goal is to minimize the use of regular expressions...\n\t\t\tvar FLOAT = /^\\s*-?(\\d*\\.?\\d+|\\d+\\.?\\d*)(e[-+]?\\d+)?\\s*$/i;\n\t\n\t\t\tvar self = this;\n\t\t\tvar _stepCounter = 0;\t// Number of times step was called (number of rows parsed)\n\t\t\tvar _input;\t\t\t\t// The input being parsed\n\t\t\tvar _parser;\t\t\t// The core parser being used\n\t\t\tvar _paused = false;\t// Whether we are paused or not\n\t\t\tvar _aborted = false;\t// Whether the parser has aborted or not\n\t\t\tvar _delimiterError;\t// Temporary state between delimiter detection and processing results\n\t\t\tvar _fields = [];\t\t// Fields are from the header row of the input, if there is one\n\t\t\tvar _results = {\t\t// The last results returned from the parser\n\t\t\t\tdata: [],\n\t\t\t\terrors: [],\n\t\t\t\tmeta: {}\n\t\t\t};\n\t\n\t\t\tif (isFunction(_config.step))\n\t\t\t{\n\t\t\t\tvar userStep = _config.step;\n\t\t\t\t_config.step = function(results)\n\t\t\t\t{\n\t\t\t\t\t_results = results;\n\t\n\t\t\t\t\tif (needsHeaderRow())\n\t\t\t\t\t\tprocessResults();\n\t\t\t\t\telse\t// only call user's step function after header row\n\t\t\t\t\t{\n\t\t\t\t\t\tprocessResults();\n\t\n\t\t\t\t\t\t// It's possbile that this line was empty and there's no row here after all\n\t\t\t\t\t\tif (_results.data.length === 0)\n\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t_stepCounter += results.data.length;\n\t\t\t\t\t\tif (_config.preview && _stepCounter > _config.preview)\n\t\t\t\t\t\t\t_parser.abort();\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tuserStep(_results, self);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\t/**\n\t\t\t * Parses input. Most users won't need, and shouldn't mess with, the baseIndex\n\t\t\t * and ignoreLastRow parameters. They are used by streamers (wrapper functions)\n\t\t\t * when an input comes in multiple chunks, like from a file.\n\t\t\t */\n\t\t\tthis.parse = function(input, baseIndex, ignoreLastRow)\n\t\t\t{\n\t\t\t\tif (!_config.newline)\n\t\t\t\t\t_config.newline = guessLineEndings(input);\n\t\n\t\t\t\t_delimiterError = false;\n\t\t\t\tif (!_config.delimiter)\n\t\t\t\t{\n\t\t\t\t\tvar delimGuess = guessDelimiter(input, _config.newline, _config.skipEmptyLines);\n\t\t\t\t\tif (delimGuess.successful)\n\t\t\t\t\t\t_config.delimiter = delimGuess.bestDelimiter;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t_delimiterError = true;\t// add error after parsing (otherwise it would be overwritten)\n\t\t\t\t\t\t_config.delimiter = Papa.DefaultDelimiter;\n\t\t\t\t\t}\n\t\t\t\t\t_results.meta.delimiter = _config.delimiter;\n\t\t\t\t}\n\t\t\t\telse if(isFunction(_config.delimiter))\n\t\t\t\t{\n\t\t\t\t\t_config.delimiter = _config.delimiter(input);\n\t\t\t\t\t_results.meta.delimiter = _config.delimiter;\n\t\t\t\t}\n\t\n\t\t\t\tvar parserConfig = copy(_config);\n\t\t\t\tif (_config.preview && _config.header)\n\t\t\t\t\tparserConfig.preview++;\t// to compensate for header row\n\t\n\t\t\t\t_input = input;\n\t\t\t\t_parser = new Parser(parserConfig);\n\t\t\t\t_results = _parser.parse(_input, baseIndex, ignoreLastRow);\n\t\t\t\tprocessResults();\n\t\t\t\treturn _paused ? { meta: { paused: true } } : (_results || { meta: { paused: false } });\n\t\t\t};\n\t\n\t\t\tthis.paused = function()\n\t\t\t{\n\t\t\t\treturn _paused;\n\t\t\t};\n\t\n\t\t\tthis.pause = function()\n\t\t\t{\n\t\t\t\t_paused = true;\n\t\t\t\t_parser.abort();\n\t\t\t\t_input = _input.substr(_parser.getCharIndex());\n\t\t\t};\n\t\n\t\t\tthis.resume = function()\n\t\t\t{\n\t\t\t\t_paused = false;\n\t\t\t\tself.streamer.parseChunk(_input);\n\t\t\t};\n\t\n\t\t\tthis.aborted = function ()\n\t\t\t{\n\t\t\t\treturn _aborted;\n\t\t\t};\n\t\n\t\t\tthis.abort = function()\n\t\t\t{\n\t\t\t\t_aborted = true;\n\t\t\t\t_parser.abort();\n\t\t\t\t_results.meta.aborted = true;\n\t\t\t\tif (isFunction(_config.complete))\n\t\t\t\t\t_config.complete(_results);\n\t\t\t\t_input = '';\n\t\t\t};\n\t\n\t\t\tfunction processResults()\n\t\t\t{\n\t\t\t\tif (_results && _delimiterError)\n\t\t\t\t{\n\t\t\t\t\taddError('Delimiter', 'UndetectableDelimiter', 'Unable to auto-detect delimiting character; defaulted to \\''+Papa.DefaultDelimiter+'\\'');\n\t\t\t\t\t_delimiterError = false;\n\t\t\t\t}\n\t\n\t\t\t\tif (_config.skipEmptyLines)\n\t\t\t\t{\n\t\t\t\t\tfor (var i = 0; i < _results.data.length; i++)\n\t\t\t\t\t\tif (_results.data[i].length === 1 && _results.data[i][0] === '')\n\t\t\t\t\t\t\t_results.data.splice(i--, 1);\n\t\t\t\t}\n\t\n\t\t\t\tif (needsHeaderRow())\n\t\t\t\t\tfillHeaderFields();\n\t\n\t\t\t\treturn applyHeaderAndDynamicTyping();\n\t\t\t}\n\t\n\t\t\tfunction needsHeaderRow()\n\t\t\t{\n\t\t\t\treturn _config.header && _fields.length === 0;\n\t\t\t}\n\t\n\t\t\tfunction fillHeaderFields()\n\t\t\t{\n\t\t\t\tif (!_results)\n\t\t\t\t\treturn;\n\t\t\t\tfor (var i = 0; needsHeaderRow() && i < _results.data.length; i++)\n\t\t\t\t\tfor (var j = 0; j < _results.data[i].length; j++)\n\t\t\t\t\t\t_fields.push(_results.data[i][j]);\n\t\t\t\t_results.data.splice(0, 1);\n\t\t\t}\n\t\n\t\t\tfunction shouldApplyDynamicTyping(field) {\n\t\t\t\t// Cache function values to avoid calling it for each row\n\t\t\t\tif (_config.dynamicTypingFunction && _config.dynamicTyping[field] === undefined) {\n\t\t\t\t\t_config.dynamicTyping[field] = _config.dynamicTypingFunction(field);\n\t\t\t\t}\n\t\t\t\treturn (_config.dynamicTyping[field] || _config.dynamicTyping) === true\n\t\t\t}\n\t\n\t\t\tfunction parseDynamic(field, value)\n\t\t\t{\n\t\t\t\tif (shouldApplyDynamicTyping(field))\n\t\t\t\t{\n\t\t\t\t\tif (value === 'true' || value === 'TRUE')\n\t\t\t\t\t\treturn true;\n\t\t\t\t\telse if (value === 'false' || value === 'FALSE')\n\t\t\t\t\t\treturn false;\n\t\t\t\t\telse\n\t\t\t\t\t\treturn tryParseFloat(value);\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\n\t\t\tfunction applyHeaderAndDynamicTyping()\n\t\t\t{\n\t\t\t\tif (!_results || (!_config.header && !_config.dynamicTyping))\n\t\t\t\t\treturn _results;\n\t\n\t\t\t\tfor (var i = 0; i < _results.data.length; i++)\n\t\t\t\t{\n\t\t\t\t\tvar row = _config.header ? {} : [];\n\t\n\t\t\t\t\tfor (var j = 0; j < _results.data[i].length; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar field = j;\n\t\t\t\t\t\tvar value = _results.data[i][j];\n\t\n\t\t\t\t\t\tif (_config.header)\n\t\t\t\t\t\t\tfield = j >= _fields.length ? '__parsed_extra' : _fields[j];\n\t\n\t\t\t\t\t\tvalue = parseDynamic(field, value);\n\t\n\t\t\t\t\t\tif (field === '__parsed_extra')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trow[field] = row[field] || [];\n\t\t\t\t\t\t\trow[field].push(value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\trow[field] = value;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t_results.data[i] = row;\n\t\n\t\t\t\t\tif (_config.header)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (j > _fields.length)\n\t\t\t\t\t\t\taddError('FieldMismatch', 'TooManyFields', 'Too many fields: expected ' + _fields.length + ' fields but parsed ' + j, i);\n\t\t\t\t\t\telse if (j < _fields.length)\n\t\t\t\t\t\t\taddError('FieldMismatch', 'TooFewFields', 'Too few fields: expected ' + _fields.length + ' fields but parsed ' + j, i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tif (_config.header && _results.meta)\n\t\t\t\t\t_results.meta.fields = _fields;\n\t\t\t\treturn _results;\n\t\t\t}\n\t\n\t\t\tfunction guessDelimiter(input, newline, skipEmptyLines)\n\t\t\t{\n\t\t\t\tvar delimChoices = [',', '\\t', '|', ';', Papa.RECORD_SEP, Papa.UNIT_SEP];\n\t\t\t\tvar bestDelim, bestDelta, fieldCountPrevRow;\n\t\n\t\t\t\tfor (var i = 0; i < delimChoices.length; i++)\n\t\t\t\t{\n\t\t\t\t\tvar delim = delimChoices[i];\n\t\t\t\t\tvar delta = 0, avgFieldCount = 0, emptyLinesCount = 0;\n\t\t\t\t\tfieldCountPrevRow = undefined;\n\t\n\t\t\t\t\tvar preview = new Parser({\n\t\t\t\t\t\tdelimiter: delim,\n\t\t\t\t\t\tnewline: newline,\n\t\t\t\t\t\tpreview: 10\n\t\t\t\t\t}).parse(input);\n\t\n\t\t\t\t\tfor (var j = 0; j < preview.data.length; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (skipEmptyLines && preview.data[j].length === 1 && preview.data[j][0].length === 0) {\n\t\t\t\t\t\t\temptyLinesCount++\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar fieldCount = preview.data[j].length;\n\t\t\t\t\t\tavgFieldCount += fieldCount;\n\t\n\t\t\t\t\t\tif (typeof fieldCountPrevRow === 'undefined')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfieldCountPrevRow = fieldCount;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (fieldCount > 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdelta += Math.abs(fieldCount - fieldCountPrevRow);\n\t\t\t\t\t\t\tfieldCountPrevRow = fieldCount;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (preview.data.length > 0)\n\t\t\t\t\t\tavgFieldCount /= (preview.data.length - emptyLinesCount);\n\t\n\t\t\t\t\tif ((typeof bestDelta === 'undefined' || delta < bestDelta)\n\t\t\t\t\t\t&& avgFieldCount > 1.99)\n\t\t\t\t\t{\n\t\t\t\t\t\tbestDelta = delta;\n\t\t\t\t\t\tbestDelim = delim;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t_config.delimiter = bestDelim;\n\t\n\t\t\t\treturn {\n\t\t\t\t\tsuccessful: !!bestDelim,\n\t\t\t\t\tbestDelimiter: bestDelim\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfunction guessLineEndings(input)\n\t\t\t{\n\t\t\t\tinput = input.substr(0, 1024*1024);\t// max length 1 MB\n\t\n\t\t\t\tvar r = input.split('\\r');\n\t\n\t\t\t\tvar n = input.split('\\n');\n\t\n\t\t\t\tvar nAppearsFirst = (n.length > 1 && n[0].length < r[0].length);\n\t\n\t\t\t\tif (r.length === 1 || nAppearsFirst)\n\t\t\t\t\treturn '\\n';\n\t\n\t\t\t\tvar numWithN = 0;\n\t\t\t\tfor (var i = 0; i < r.length; i++)\n\t\t\t\t{\n\t\t\t\t\tif (r[i][0] === '\\n')\n\t\t\t\t\t\tnumWithN++;\n\t\t\t\t}\n\t\n\t\t\t\treturn numWithN >= r.length / 2 ? '\\r\\n' : '\\r';\n\t\t\t}\n\t\n\t\t\tfunction tryParseFloat(val)\n\t\t\t{\n\t\t\t\tvar isNumber = FLOAT.test(val);\n\t\t\t\treturn isNumber ? parseFloat(val) : val;\n\t\t\t}\n\t\n\t\t\tfunction addError(type, code, msg, row)\n\t\t\t{\n\t\t\t\t_results.errors.push({\n\t\t\t\t\ttype: type,\n\t\t\t\t\tcode: code,\n\t\t\t\t\tmessage: msg,\n\t\t\t\t\trow: row\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\n\t\n\t\n\t\n\t\n\t\t/** The core parser implements speedy and correct CSV parsing */\n\t\tfunction Parser(config)\n\t\t{\n\t\t\t// Unpack the config object\n\t\t\tconfig = config || {};\n\t\t\tvar delim = config.delimiter;\n\t\t\tvar newline = config.newline;\n\t\t\tvar comments = config.comments;\n\t\t\tvar step = config.step;\n\t\t\tvar preview = config.preview;\n\t\t\tvar fastMode = config.fastMode;\n\t\t\t/** Allows for no quoteChar by setting quoteChar to undefined in config */\n\t\t\tif (config.quoteChar === undefined){\n\t\t\t\tvar quoteChar = '\"';\n\t\t\t} else {\n\t\t\t\tvar quoteChar = config.quoteChar;\n\t\t\t}\n\t\n\t\t\t// Delimiter must be valid\n\t\t\tif (typeof delim !== 'string'\n\t\t\t\t|| Papa.BAD_DELIMITERS.indexOf(delim) > -1)\n\t\t\t\tdelim = ',';\n\t\n\t\t\t// Comment character must be valid\n\t\t\tif (comments === delim)\n\t\t\t\tthrow 'Comment character same as delimiter';\n\t\t\telse if (comments === true)\n\t\t\t\tcomments = '#';\n\t\t\telse if (typeof comments !== 'string'\n\t\t\t\t|| Papa.BAD_DELIMITERS.indexOf(comments) > -1)\n\t\t\t\tcomments = false;\n\t\n\t\t\t// Newline must be valid: \\r, \\n, or \\r\\n\n\t\t\tif (newline != '\\n' && newline != '\\r' && newline != '\\r\\n')\n\t\t\t\tnewline = '\\n';\n\t\n\t\t\t// We're gonna need these at the Parser scope\n\t\t\tvar cursor = 0;\n\t\t\tvar aborted = false;\n\t\n\t\t\tthis.parse = function(input, baseIndex, ignoreLastRow)\n\t\t\t{\n\t\t\t\t// For some reason, in Chrome, this speeds things up (!?)\n\t\t\t\tif (typeof input !== 'string')\n\t\t\t\t\tthrow 'Input must be a string';\n\t\n\t\t\t\t// We don't need to compute some of these every time parse() is called,\n\t\t\t\t// but having them in a more local scope seems to perform better\n\t\t\t\tvar inputLen = input.length,\n\t\t\t\t\tdelimLen = delim.length,\n\t\t\t\t\tnewlineLen = newline.length,\n\t\t\t\t\tcommentsLen = comments.length;\n\t\t\t\tvar stepIsFunction = isFunction(step);\n\t\n\t\t\t\t// Establish starting state\n\t\t\t\tcursor = 0;\n\t\t\t\tvar data = [], errors = [], row = [], lastCursor = 0;\n\t\n\t\t\t\tif (!input)\n\t\t\t\t\treturn returnable();\n\t\n\t\t\t\tif (fastMode || (fastMode !== false && input.indexOf(quoteChar) === -1))\n\t\t\t\t{\n\t\t\t\t\tvar rows = input.split(newline);\n\t\t\t\t\tfor (var i = 0; i < rows.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar row = rows[i];\n\t\t\t\t\t\tcursor += row.length;\n\t\t\t\t\t\tif (i !== rows.length - 1)\n\t\t\t\t\t\t\tcursor += newline.length;\n\t\t\t\t\t\telse if (ignoreLastRow)\n\t\t\t\t\t\t\treturn returnable();\n\t\t\t\t\t\tif (comments && row.substr(0, commentsLen) === comments)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (stepIsFunction)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdata = [];\n\t\t\t\t\t\t\tpushRow(row.split(delim));\n\t\t\t\t\t\t\tdoStep();\n\t\t\t\t\t\t\tif (aborted)\n\t\t\t\t\t\t\t\treturn returnable();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tpushRow(row.split(delim));\n\t\t\t\t\t\tif (preview && i >= preview)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdata = data.slice(0, preview);\n\t\t\t\t\t\t\treturn returnable(true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn returnable();\n\t\t\t\t}\n\t\n\t\t\t\tvar nextDelim = input.indexOf(delim, cursor);\n\t\t\t\tvar nextNewline = input.indexOf(newline, cursor);\n\t\t\t\tvar quoteCharRegex = new RegExp(quoteChar+quoteChar, 'g');\n\t\n\t\t\t\t// Parser loop\n\t\t\t\tfor (;;)\n\t\t\t\t{\n\t\t\t\t\t// Field has opening quote\n\t\t\t\t\tif (input[cursor] === quoteChar)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Start our search for the closing quote where the cursor is\n\t\t\t\t\t\tvar quoteSearch = cursor;\n\t\n\t\t\t\t\t\t// Skip the opening quote\n\t\t\t\t\t\tcursor++;\n\t\n\t\t\t\t\t\tfor (;;)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Find closing quote\n\t\t\t\t\t\t\tvar quoteSearch = input.indexOf(quoteChar, quoteSearch+1);\n\t\n\t\t\t\t\t\t\t//No other quotes are found - no other delimiters\n\t\t\t\t\t\t\tif (quoteSearch === -1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (!ignoreLastRow) {\n\t\t\t\t\t\t\t\t\t// No closing quote... what a pity\n\t\t\t\t\t\t\t\t\terrors.push({\n\t\t\t\t\t\t\t\t\t\ttype: 'Quotes',\n\t\t\t\t\t\t\t\t\t\tcode: 'MissingQuotes',\n\t\t\t\t\t\t\t\t\t\tmessage: 'Quoted field unterminated',\n\t\t\t\t\t\t\t\t\t\trow: data.length,\t// row has yet to be inserted\n\t\t\t\t\t\t\t\t\t\tindex: cursor\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn finish();\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// Closing quote at EOF\n\t\t\t\t\t\t\tif (quoteSearch === inputLen-1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar value = input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar);\n\t\t\t\t\t\t\t\treturn finish(value);\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// If this quote is escaped, it's part of the data; skip it\n\t\t\t\t\t\t\tif (input[quoteSearch+1] === quoteChar)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tquoteSearch++;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// Closing quote followed by delimiter\n\t\t\t\t\t\t\tif (input[quoteSearch+1] === delim)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trow.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));\n\t\t\t\t\t\t\t\tcursor = quoteSearch + 1 + delimLen;\n\t\t\t\t\t\t\t\tnextDelim = input.indexOf(delim, cursor);\n\t\t\t\t\t\t\t\tnextNewline = input.indexOf(newline, cursor);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// Closing quote followed by newline\n\t\t\t\t\t\t\tif (input.substr(quoteSearch+1, newlineLen) === newline)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trow.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));\n\t\t\t\t\t\t\t\tsaveRow(quoteSearch + 1 + newlineLen);\n\t\t\t\t\t\t\t\tnextDelim = input.indexOf(delim, cursor);\t// because we may have skipped the nextDelim in the quoted field\n\t\n\t\t\t\t\t\t\t\tif (stepIsFunction)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tdoStep();\n\t\t\t\t\t\t\t\t\tif (aborted)\n\t\t\t\t\t\t\t\t\t\treturn returnable();\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\tif (preview && data.length >= preview)\n\t\t\t\t\t\t\t\t\treturn returnable(true);\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\n\t\n\t\t\t\t\t\t\t// Checks for valid closing quotes are complete (escaped quotes or quote followed by EOF/delimiter/newline) -- assume these quotes are part of an invalid text string\n\t\t\t\t\t\t\terrors.push({\n\t\t\t\t\t\t\t\ttype: 'Quotes',\n\t\t\t\t\t\t\t\tcode: 'InvalidQuotes',\n\t\t\t\t\t\t\t\tmessage: 'Trailing quote on quoted field is malformed',\n\t\t\t\t\t\t\t\trow: data.length,\t// row has yet to be inserted\n\t\t\t\t\t\t\t\tindex: cursor\n\t\t\t\t\t\t\t});\n\t\n\t\t\t\t\t\t\tquoteSearch++;\n\t\t\t\t\t\t\tcontinue;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Comment found at start of new line\n\t\t\t\t\tif (comments && row.length === 0 && input.substr(cursor, commentsLen) === comments)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (nextNewline === -1)\t// Comment ends at EOF\n\t\t\t\t\t\t\treturn returnable();\n\t\t\t\t\t\tcursor = nextNewline + newlineLen;\n\t\t\t\t\t\tnextNewline = input.indexOf(newline, cursor);\n\t\t\t\t\t\tnextDelim = input.indexOf(delim, cursor);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Next delimiter comes before next newline, so we've reached end of field\n\t\t\t\t\tif (nextDelim !== -1 && (nextDelim < nextNewline || nextNewline === -1))\n\t\t\t\t\t{\n\t\t\t\t\t\trow.push(input.substring(cursor, nextDelim));\n\t\t\t\t\t\tcursor = nextDelim + delimLen;\n\t\t\t\t\t\tnextDelim = input.indexOf(delim, cursor);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// End of row\n\t\t\t\t\tif (nextNewline !== -1)\n\t\t\t\t\t{\n\t\t\t\t\t\trow.push(input.substring(cursor, nextNewline));\n\t\t\t\t\t\tsaveRow(nextNewline + newlineLen);\n\t\n\t\t\t\t\t\tif (stepIsFunction)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdoStep();\n\t\t\t\t\t\t\tif (aborted)\n\t\t\t\t\t\t\t\treturn returnable();\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif (preview && data.length >= preview)\n\t\t\t\t\t\t\treturn returnable(true);\n\t\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\n\t\n\t\t\t\treturn finish();\n\t\n\t\n\t\t\t\tfunction pushRow(row)\n\t\t\t\t{\n\t\t\t\t\tdata.push(row);\n\t\t\t\t\tlastCursor = cursor;\n\t\t\t\t}\n\t\n\t\t\t\t/**\n\t\t\t\t * Appends the remaining input from cursor to the end into\n\t\t\t\t * row, saves the row, calls step, and returns the results.\n\t\t\t\t */\n\t\t\t\tfunction finish(value)\n\t\t\t\t{\n\t\t\t\t\tif (ignoreLastRow)\n\t\t\t\t\t\treturn returnable();\n\t\t\t\t\tif (typeof value === 'undefined')\n\t\t\t\t\t\tvalue = input.substr(cursor);\n\t\t\t\t\trow.push(value);\n\t\t\t\t\tcursor = inputLen;\t// important in case parsing is paused\n\t\t\t\t\tpushRow(row);\n\t\t\t\t\tif (stepIsFunction)\n\t\t\t\t\t\tdoStep();\n\t\t\t\t\treturn returnable();\n\t\t\t\t}\n\t\n\t\t\t\t/**\n\t\t\t\t * Appends the current row to the results. It sets the cursor\n\t\t\t\t * to newCursor and finds the nextNewline. The caller should\n\t\t\t\t * take care to execute user's step function and check for\n\t\t\t\t * preview and end parsing if necessary.\n\t\t\t\t */\n\t\t\t\tfunction saveRow(newCursor)\n\t\t\t\t{\n\t\t\t\t\tcursor = newCursor;\n\t\t\t\t\tpushRow(row);\n\t\t\t\t\trow = [];\n\t\t\t\t\tnextNewline = input.indexOf(newline, cursor);\n\t\t\t\t}\n\t\n\t\t\t\t/** Returns an object with the results, errors, and meta. */\n\t\t\t\tfunction returnable(stopped)\n\t\t\t\t{\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdata: data,\n\t\t\t\t\t\terrors: errors,\n\t\t\t\t\t\tmeta: {\n\t\t\t\t\t\t\tdelimiter: delim,\n\t\t\t\t\t\t\tlinebreak: newline,\n\t\t\t\t\t\t\taborted: aborted,\n\t\t\t\t\t\t\ttruncated: !!stopped,\n\t\t\t\t\t\t\tcursor: lastCursor + (baseIndex || 0)\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\n\t\t\t\t/** Executes the user's step function and resets data & errors. */\n\t\t\t\tfunction doStep()\n\t\t\t\t{\n\t\t\t\t\tstep(returnable());\n\t\t\t\t\tdata = [], errors = [];\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\t/** Sets the abort flag */\n\t\t\tthis.abort = function()\n\t\t\t{\n\t\t\t\taborted = true;\n\t\t\t};\n\t\n\t\t\t/** Gets the cursor position */\n\t\t\tthis.getCharIndex = function()\n\t\t\t{\n\t\t\t\treturn cursor;\n\t\t\t};\n\t\t}\n\t\n\t\n\t\t// If you need to load Papa Parse asynchronously and you also need worker threads, hard-code\n\t\t// the script path here. See: https://github.com/mholt/PapaParse/issues/87#issuecomment-57885358\n\t\tfunction getScriptPath()\n\t\t{\n\t\t\tvar scripts = document.getElementsByTagName('script');\n\t\t\treturn scripts.length ? scripts[scripts.length - 1].src : '';\n\t\t}\n\t\n\t\tfunction newWorker()\n\t\t{\n\t\t\tif (!Papa.WORKERS_SUPPORTED)\n\t\t\t\treturn false;\n\t\t\tif (!LOADED_SYNC && Papa.SCRIPT_PATH === null)\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Script path cannot be determined automatically when Papa Parse is loaded asynchronously. ' +\n\t\t\t\t\t'You need to set Papa.SCRIPT_PATH manually.'\n\t\t\t\t);\n\t\t\tvar workerUrl = Papa.SCRIPT_PATH || AUTO_SCRIPT_PATH;\n\t\t\t// Append 'papaworker' to the search string to tell papaparse that this is our worker.\n\t\t\tworkerUrl += (workerUrl.indexOf('?') !== -1 ? '&' : '?') + 'papaworker';\n\t\t\tvar w = new global.Worker(workerUrl);\n\t\t\tw.onmessage = mainThreadReceivedMessage;\n\t\t\tw.id = workerIdCounter++;\n\t\t\tworkers[w.id] = w;\n\t\t\treturn w;\n\t\t}\n\t\n\t\t/** Callback when main thread receives a message */\n\t\tfunction mainThreadReceivedMessage(e)\n\t\t{\n\t\t\tvar msg = e.data;\n\t\t\tvar worker = workers[msg.workerId];\n\t\t\tvar aborted = false;\n\t\n\t\t\tif (msg.error)\n\t\t\t\tworker.userError(msg.error, msg.file);\n\t\t\telse if (msg.results && msg.results.data)\n\t\t\t{\n\t\t\t\tvar abort = function() {\n\t\t\t\t\taborted = true;\n\t\t\t\t\tcompleteWorker(msg.workerId, { data: [], errors: [], meta: { aborted: true } });\n\t\t\t\t};\n\t\n\t\t\t\tvar handle = {\n\t\t\t\t\tabort: abort,\n\t\t\t\t\tpause: notImplemented,\n\t\t\t\t\tresume: notImplemented\n\t\t\t\t};\n\t\n\t\t\t\tif (isFunction(worker.userStep))\n\t\t\t\t{\n\t\t\t\t\tfor (var i = 0; i < msg.results.data.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tworker.userStep({\n\t\t\t\t\t\t\tdata: [msg.results.data[i]],\n\t\t\t\t\t\t\terrors: msg.results.errors,\n\t\t\t\t\t\t\tmeta: msg.results.meta\n\t\t\t\t\t\t}, handle);\n\t\t\t\t\t\tif (aborted)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdelete msg.results;\t// free memory ASAP\n\t\t\t\t}\n\t\t\t\telse if (isFunction(worker.userChunk))\n\t\t\t\t{\n\t\t\t\t\tworker.userChunk(msg.results, handle, msg.file);\n\t\t\t\t\tdelete msg.results;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif (msg.finished && !aborted)\n\t\t\t\tcompleteWorker(msg.workerId, msg.results);\n\t\t}\n\t\n\t\tfunction completeWorker(workerId, results) {\n\t\t\tvar worker = workers[workerId];\n\t\t\tif (isFunction(worker.userComplete))\n\t\t\t\tworker.userComplete(results);\n\t\t\tworker.terminate();\n\t\t\tdelete workers[workerId];\n\t\t}\n\t\n\t\tfunction notImplemented() {\n\t\t\tthrow 'Not implemented.';\n\t\t}\n\t\n\t\t/** Callback when worker thread receives a message */\n\t\tfunction workerThreadReceivedMessage(e)\n\t\t{\n\t\t\tvar msg = e.data;\n\t\n\t\t\tif (typeof Papa.WORKER_ID === 'undefined' && msg)\n\t\t\t\tPapa.WORKER_ID = msg.workerId;\n\t\n\t\t\tif (typeof msg.input === 'string')\n\t\t\t{\n\t\t\t\tglobal.postMessage({\n\t\t\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\t\t\tresults: Papa.parse(msg.input, msg.config),\n\t\t\t\t\tfinished: true\n\t\t\t\t});\n\t\t\t}\n\t\t\telse if ((global.File && msg.input instanceof File) || msg.input instanceof Object)\t// thank you, Safari (see issue #106)\n\t\t\t{\n\t\t\t\tvar results = Papa.parse(msg.input, msg.config);\n\t\t\t\tif (results)\n\t\t\t\t\tglobal.postMessage({\n\t\t\t\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\t\t\t\tresults: results,\n\t\t\t\t\t\tfinished: true\n\t\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\n\t\t/** Makes a deep copy of an array or object (mostly) */\n\t\tfunction copy(obj)\n\t\t{\n\t\t\tif (typeof obj !== 'object')\n\t\t\t\treturn obj;\n\t\t\tvar cpy = obj instanceof Array ? [] : {};\n\t\t\tfor (var key in obj)\n\t\t\t\tcpy[key] = copy(obj[key]);\n\t\t\treturn cpy;\n\t\t}\n\t\n\t\tfunction bindFunction(f, self)\n\t\t{\n\t\t\treturn function() { f.apply(self, arguments); };\n\t\t}\n\t\n\t\tfunction isFunction(func)\n\t\t{\n\t\t\treturn typeof func === 'function';\n\t\t}\n\t\n\t\treturn Papa;\n\t}));\n\n\n/***/ }),\n\n/***/ 212:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\texports.booksQuery = undefined;\n\t\n\tvar _react = __webpack_require__(3);\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\tvar _gatsbyLink = __webpack_require__(46);\n\t\n\tvar _gatsbyLink2 = _interopRequireDefault(_gatsbyLink);\n\t\n\tvar _styledComponents = __webpack_require__(26);\n\t\n\tvar _styledComponents2 = _interopRequireDefault(_styledComponents);\n\t\n\tvar _papaparse = __webpack_require__(338);\n\t\n\tvar _papaparse2 = _interopRequireDefault(_papaparse);\n\t\n\tvar _styled = __webpack_require__(41);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = function (_ref) {\n\t  var data = _ref.data;\n\t  var books = data.allBooksCsv.edges;\n\t\n\t\n\t  var booksArr = books.map(function (item) {\n\t    var node = item.node;\n\t    return {\n\t      author: node.author,\n\t      book: node.book,\n\t      cover: node.cover,\n\t      favorite: node.favorite.toLowerCase() === \"true\",\n\t      genre: node.genre.split(\",\"),\n\t      isbn: parseInt(node.isbn, 10),\n\t      pages: parseInt(node.pages, 10)\n\t    };\n\t  });\n\t\n\t  return _react2.default.createElement(\n\t    _styled.Container,\n\t    null,\n\t    _react2.default.createElement(\n\t      _styled.TitleWrapper,\n\t      null,\n\t      _react2.default.createElement(\n\t        _styled.Title,\n\t        null,\n\t        'Playground'\n\t      ),\n\t      _react2.default.createElement('div', { id: 'chart' })\n\t    ),\n\t    _react2.default.createElement(_styled.Content, null)\n\t  );\n\t};\n\t\n\tvar booksQuery = exports.booksQuery = '** extracted graphql fragment **';\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// component---src-pages-playground-js-b0f4bc38391e6fc3cd31.js","/*!\n\tPapa Parse\n\tv4.3.7\n\thttps://github.com/mholt/PapaParse\n\tLicense: MIT\n*/\n(function(root, factory)\n{\n\tif (typeof define === 'function' && define.amd)\n\t{\n\t\t// AMD. Register as an anonymous module.\n\t\tdefine([], factory);\n\t}\n\telse if (typeof module === 'object' && typeof exports !== 'undefined')\n\t{\n\t\t// Node. Does not work with strict CommonJS, but\n\t\t// only CommonJS-like environments that support module.exports,\n\t\t// like Node.\n\t\tmodule.exports = factory();\n\t}\n\telse\n\t{\n\t\t// Browser globals (root is window)\n\t\troot.Papa = factory();\n\t}\n}(this, function()\n{\n\t'use strict';\n\n\tvar global = (function () {\n\t\t// alternative method, similar to `Function('return this')()`\n\t\t// but without using `eval` (which is disabled when\n\t\t// using Content Security Policy).\n\n\t\tif (typeof self !== 'undefined') { return self; }\n\t\tif (typeof window !== 'undefined') { return window; }\n\t\tif (typeof global !== 'undefined') { return global; }\n\n\t\t// When running tests none of the above have been defined\n\t\treturn {};\n\t})();\n\n\n\tvar IS_WORKER = !global.document && !!global.postMessage,\n\t\tIS_PAPA_WORKER = IS_WORKER && /(\\?|&)papaworker(=|&|$)/.test(global.location.search),\n\t\tLOADED_SYNC = false, AUTO_SCRIPT_PATH;\n\tvar workers = {}, workerIdCounter = 0;\n\n\tvar Papa = {};\n\n\tPapa.parse = CsvToJson;\n\tPapa.unparse = JsonToCsv;\n\n\tPapa.RECORD_SEP = String.fromCharCode(30);\n\tPapa.UNIT_SEP = String.fromCharCode(31);\n\tPapa.BYTE_ORDER_MARK = '\\ufeff';\n\tPapa.BAD_DELIMITERS = ['\\r', '\\n', '\"', Papa.BYTE_ORDER_MARK];\n\tPapa.WORKERS_SUPPORTED = !IS_WORKER && !!global.Worker;\n\tPapa.SCRIPT_PATH = null;\t// Must be set by your code if you use workers and this lib is loaded asynchronously\n\n\t// Configurable chunk sizes for local and remote files, respectively\n\tPapa.LocalChunkSize = 1024 * 1024 * 10;\t// 10 MB\n\tPapa.RemoteChunkSize = 1024 * 1024 * 5;\t// 5 MB\n\tPapa.DefaultDelimiter = ',';\t\t\t// Used if not specified and detection fails\n\n\t// Exposed for testing and development only\n\tPapa.Parser = Parser;\n\tPapa.ParserHandle = ParserHandle;\n\tPapa.NetworkStreamer = NetworkStreamer;\n\tPapa.FileStreamer = FileStreamer;\n\tPapa.StringStreamer = StringStreamer;\n\tPapa.ReadableStreamStreamer = ReadableStreamStreamer;\n\n\tif (global.jQuery)\n\t{\n\t\tvar $ = global.jQuery;\n\t\t$.fn.parse = function(options)\n\t\t{\n\t\t\tvar config = options.config || {};\n\t\t\tvar queue = [];\n\n\t\t\tthis.each(function(idx)\n\t\t\t{\n\t\t\t\tvar supported = $(this).prop('tagName').toUpperCase() === 'INPUT'\n\t\t\t\t\t\t\t\t&& $(this).attr('type').toLowerCase() === 'file'\n\t\t\t\t\t\t\t\t&& global.FileReader;\n\n\t\t\t\tif (!supported || !this.files || this.files.length === 0)\n\t\t\t\t\treturn true;\t// continue to next input element\n\n\t\t\t\tfor (var i = 0; i < this.files.length; i++)\n\t\t\t\t{\n\t\t\t\t\tqueue.push({\n\t\t\t\t\t\tfile: this.files[i],\n\t\t\t\t\t\tinputElem: this,\n\t\t\t\t\t\tinstanceConfig: $.extend({}, config)\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tparseNextFile();\t// begin parsing\n\t\t\treturn this;\t\t// maintains chainability\n\n\n\t\t\tfunction parseNextFile()\n\t\t\t{\n\t\t\t\tif (queue.length === 0)\n\t\t\t\t{\n\t\t\t\t\tif (isFunction(options.complete))\n\t\t\t\t\t\toptions.complete();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar f = queue[0];\n\n\t\t\t\tif (isFunction(options.before))\n\t\t\t\t{\n\t\t\t\t\tvar returned = options.before(f.file, f.inputElem);\n\n\t\t\t\t\tif (typeof returned === 'object')\n\t\t\t\t\t{\n\t\t\t\t\t\tif (returned.action === 'abort')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\terror('AbortError', f.file, f.inputElem, returned.reason);\n\t\t\t\t\t\t\treturn;\t// Aborts all queued files immediately\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (returned.action === 'skip')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfileComplete();\t// parse the next file in the queue, if any\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (typeof returned.config === 'object')\n\t\t\t\t\t\t\tf.instanceConfig = $.extend(f.instanceConfig, returned.config);\n\t\t\t\t\t}\n\t\t\t\t\telse if (returned === 'skip')\n\t\t\t\t\t{\n\t\t\t\t\t\tfileComplete();\t// parse the next file in the queue, if any\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Wrap up the user's complete callback, if any, so that ours also gets executed\n\t\t\t\tvar userCompleteFunc = f.instanceConfig.complete;\n\t\t\t\tf.instanceConfig.complete = function(results)\n\t\t\t\t{\n\t\t\t\t\tif (isFunction(userCompleteFunc))\n\t\t\t\t\t\tuserCompleteFunc(results, f.file, f.inputElem);\n\t\t\t\t\tfileComplete();\n\t\t\t\t};\n\n\t\t\t\tPapa.parse(f.file, f.instanceConfig);\n\t\t\t}\n\n\t\t\tfunction error(name, file, elem, reason)\n\t\t\t{\n\t\t\t\tif (isFunction(options.error))\n\t\t\t\t\toptions.error({name: name}, file, elem, reason);\n\t\t\t}\n\n\t\t\tfunction fileComplete()\n\t\t\t{\n\t\t\t\tqueue.splice(0, 1);\n\t\t\t\tparseNextFile();\n\t\t\t}\n\t\t}\n\t}\n\n\n\tif (IS_PAPA_WORKER)\n\t{\n\t\tglobal.onmessage = workerThreadReceivedMessage;\n\t}\n\telse if (Papa.WORKERS_SUPPORTED)\n\t{\n\t\tAUTO_SCRIPT_PATH = getScriptPath();\n\n\t\t// Check if the script was loaded synchronously\n\t\tif (!document.body)\n\t\t{\n\t\t\t// Body doesn't exist yet, must be synchronous\n\t\t\tLOADED_SYNC = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdocument.addEventListener('DOMContentLoaded', function () {\n\t\t\t\tLOADED_SYNC = true;\n\t\t\t}, true);\n\t\t}\n\t}\n\n\n\n\n\tfunction CsvToJson(_input, _config)\n\t{\n\t\t_config = _config || {};\n\t\tvar dynamicTyping = _config.dynamicTyping || false;\n\t\tif (isFunction(dynamicTyping)) {\n\t\t\t_config.dynamicTypingFunction = dynamicTyping;\n\t\t\t// Will be filled on first row call\n\t\t\tdynamicTyping = {};\n\t\t}\n\t\t_config.dynamicTyping = dynamicTyping;\n\n\t\tif (_config.worker && Papa.WORKERS_SUPPORTED)\n\t\t{\n\t\t\tvar w = newWorker();\n\n\t\t\tw.userStep = _config.step;\n\t\t\tw.userChunk = _config.chunk;\n\t\t\tw.userComplete = _config.complete;\n\t\t\tw.userError = _config.error;\n\n\t\t\t_config.step = isFunction(_config.step);\n\t\t\t_config.chunk = isFunction(_config.chunk);\n\t\t\t_config.complete = isFunction(_config.complete);\n\t\t\t_config.error = isFunction(_config.error);\n\t\t\tdelete _config.worker;\t// prevent infinite loop\n\n\t\t\tw.postMessage({\n\t\t\t\tinput: _input,\n\t\t\t\tconfig: _config,\n\t\t\t\tworkerId: w.id\n\t\t\t});\n\n\t\t\treturn;\n\t\t}\n\n\t\tvar streamer = null;\n\t\tif (typeof _input === 'string')\n\t\t{\n\t\t\tif (_config.download)\n\t\t\t\tstreamer = new NetworkStreamer(_config);\n\t\t\telse\n\t\t\t\tstreamer = new StringStreamer(_config);\n\t\t}\n\t\telse if (_input.readable === true && isFunction(_input.read) && isFunction(_input.on))\n\t\t{\n\t\t\tstreamer = new ReadableStreamStreamer(_config);\n\t\t}\n\t\telse if ((global.File && _input instanceof File) || _input instanceof Object)\t// ...Safari. (see issue #106)\n\t\t\tstreamer = new FileStreamer(_config);\n\n\t\treturn streamer.stream(_input);\n\t}\n\n\n\n\n\n\n\tfunction JsonToCsv(_input, _config)\n\t{\n\t\tvar _output = '';\n\t\tvar _fields = [];\n\n\t\t// Default configuration\n\n\t\t/** whether to surround every datum with quotes */\n\t\tvar _quotes = false;\n\n\t\t/** whether to write headers */\n\t\tvar _writeHeader = true;\n\n\t\t/** delimiting character */\n\t\tvar _delimiter = ',';\n\n\t\t/** newline character(s) */\n\t\tvar _newline = '\\r\\n';\n\n\t\t/** quote character */\n\t\tvar _quoteChar = '\"';\n\n\t\tunpackConfig();\n\n\t\tvar quoteCharRegex = new RegExp(_quoteChar, 'g');\n\n\t\tif (typeof _input === 'string')\n\t\t\t_input = JSON.parse(_input);\n\n\t\tif (_input instanceof Array)\n\t\t{\n\t\t\tif (!_input.length || _input[0] instanceof Array)\n\t\t\t\treturn serialize(null, _input);\n\t\t\telse if (typeof _input[0] === 'object')\n\t\t\t\treturn serialize(objectKeys(_input[0]), _input);\n\t\t}\n\t\telse if (typeof _input === 'object')\n\t\t{\n\t\t\tif (typeof _input.data === 'string')\n\t\t\t\t_input.data = JSON.parse(_input.data);\n\n\t\t\tif (_input.data instanceof Array)\n\t\t\t{\n\t\t\t\tif (!_input.fields)\n\t\t\t\t\t_input.fields =  _input.meta && _input.meta.fields;\n\n\t\t\t\tif (!_input.fields)\n\t\t\t\t\t_input.fields =  _input.data[0] instanceof Array\n\t\t\t\t\t\t\t\t\t? _input.fields\n\t\t\t\t\t\t\t\t\t: objectKeys(_input.data[0]);\n\n\t\t\t\tif (!(_input.data[0] instanceof Array) && typeof _input.data[0] !== 'object')\n\t\t\t\t\t_input.data = [_input.data];\t// handles input like [1,2,3] or ['asdf']\n\t\t\t}\n\n\t\t\treturn serialize(_input.fields || [], _input.data || []);\n\t\t}\n\n\t\t// Default (any valid paths should return before this)\n\t\tthrow 'exception: Unable to serialize unrecognized input';\n\n\n\t\tfunction unpackConfig()\n\t\t{\n\t\t\tif (typeof _config !== 'object')\n\t\t\t\treturn;\n\n\t\t\tif (typeof _config.delimiter === 'string'\n\t\t\t\t&& _config.delimiter.length === 1\n\t\t\t\t&& Papa.BAD_DELIMITERS.indexOf(_config.delimiter) === -1)\n\t\t\t{\n\t\t\t\t_delimiter = _config.delimiter;\n\t\t\t}\n\n\t\t\tif (typeof _config.quotes === 'boolean'\n\t\t\t\t|| _config.quotes instanceof Array)\n\t\t\t\t_quotes = _config.quotes;\n\n\t\t\tif (typeof _config.newline === 'string')\n\t\t\t\t_newline = _config.newline;\n\n\t\t\tif (typeof _config.quoteChar === 'string')\n\t\t\t\t_quoteChar = _config.quoteChar;\n\n\t\t\tif (typeof _config.header === 'boolean')\n\t\t\t\t_writeHeader = _config.header;\n\t\t}\n\n\n\t\t/** Turns an object's keys into an array */\n\t\tfunction objectKeys(obj)\n\t\t{\n\t\t\tif (typeof obj !== 'object')\n\t\t\t\treturn [];\n\t\t\tvar keys = [];\n\t\t\tfor (var key in obj)\n\t\t\t\tkeys.push(key);\n\t\t\treturn keys;\n\t\t}\n\n\t\t/** The double for loop that iterates the data and writes out a CSV string including header row */\n\t\tfunction serialize(fields, data)\n\t\t{\n\t\t\tvar csv = '';\n\n\t\t\tif (typeof fields === 'string')\n\t\t\t\tfields = JSON.parse(fields);\n\t\t\tif (typeof data === 'string')\n\t\t\t\tdata = JSON.parse(data);\n\n\t\t\tvar hasHeader = fields instanceof Array && fields.length > 0;\n\t\t\tvar dataKeyedByField = !(data[0] instanceof Array);\n\n\t\t\t// If there a header row, write it first\n\t\t\tif (hasHeader && _writeHeader)\n\t\t\t{\n\t\t\t\tfor (var i = 0; i < fields.length; i++)\n\t\t\t\t{\n\t\t\t\t\tif (i > 0)\n\t\t\t\t\t\tcsv += _delimiter;\n\t\t\t\t\tcsv += safe(fields[i], i);\n\t\t\t\t}\n\t\t\t\tif (data.length > 0)\n\t\t\t\t\tcsv += _newline;\n\t\t\t}\n\n\t\t\t// Then write out the data\n\t\t\tfor (var row = 0; row < data.length; row++)\n\t\t\t{\n\t\t\t\tvar maxCol = hasHeader ? fields.length : data[row].length;\n\n\t\t\t\tfor (var col = 0; col < maxCol; col++)\n\t\t\t\t{\n\t\t\t\t\tif (col > 0)\n\t\t\t\t\t\tcsv += _delimiter;\n\t\t\t\t\tvar colIdx = hasHeader && dataKeyedByField ? fields[col] : col;\n\t\t\t\t\tcsv += safe(data[row][colIdx], col);\n\t\t\t\t}\n\n\t\t\t\tif (row < data.length - 1)\n\t\t\t\t\tcsv += _newline;\n\t\t\t}\n\n\t\t\treturn csv;\n\t\t}\n\n\t\t/** Encloses a value around quotes if needed (makes a value safe for CSV insertion) */\n\t\tfunction safe(str, col)\n\t\t{\n\t\t\tif (typeof str === 'undefined' || str === null)\n\t\t\t\treturn '';\n\n\t\t\tstr = str.toString().replace(quoteCharRegex, _quoteChar+_quoteChar);\n\n\t\t\tvar needsQuotes = (typeof _quotes === 'boolean' && _quotes)\n\t\t\t\t\t\t\t|| (_quotes instanceof Array && _quotes[col])\n\t\t\t\t\t\t\t|| hasAny(str, Papa.BAD_DELIMITERS)\n\t\t\t\t\t\t\t|| str.indexOf(_delimiter) > -1\n\t\t\t\t\t\t\t|| str.charAt(0) === ' '\n\t\t\t\t\t\t\t|| str.charAt(str.length - 1) === ' ';\n\n\t\t\treturn needsQuotes ? _quoteChar + str + _quoteChar : str;\n\t\t}\n\n\t\tfunction hasAny(str, substrings)\n\t\t{\n\t\t\tfor (var i = 0; i < substrings.length; i++)\n\t\t\t\tif (str.indexOf(substrings[i]) > -1)\n\t\t\t\t\treturn true;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/** ChunkStreamer is the base prototype for various streamer implementations. */\n\tfunction ChunkStreamer(config)\n\t{\n\t\tthis._handle = null;\n\t\tthis._paused = false;\n\t\tthis._finished = false;\n\t\tthis._input = null;\n\t\tthis._baseIndex = 0;\n\t\tthis._partialLine = '';\n\t\tthis._rowCount = 0;\n\t\tthis._start = 0;\n\t\tthis._nextChunk = null;\n\t\tthis.isFirstChunk = true;\n\t\tthis._completeResults = {\n\t\t\tdata: [],\n\t\t\terrors: [],\n\t\t\tmeta: {}\n\t\t};\n\t\treplaceConfig.call(this, config);\n\n\t\tthis.parseChunk = function(chunk)\n\t\t{\n\t\t\t// First chunk pre-processing\n\t\t\tif (this.isFirstChunk && isFunction(this._config.beforeFirstChunk))\n\t\t\t{\n\t\t\t\tvar modifiedChunk = this._config.beforeFirstChunk(chunk);\n\t\t\t\tif (modifiedChunk !== undefined)\n\t\t\t\t\tchunk = modifiedChunk;\n\t\t\t}\n\t\t\tthis.isFirstChunk = false;\n\n\t\t\t// Rejoin the line we likely just split in two by chunking the file\n\t\t\tvar aggregate = this._partialLine + chunk;\n\t\t\tthis._partialLine = '';\n\n\t\t\tvar results = this._handle.parse(aggregate, this._baseIndex, !this._finished);\n\n\t\t\tif (this._handle.paused() || this._handle.aborted())\n\t\t\t\treturn;\n\n\t\t\tvar lastIndex = results.meta.cursor;\n\n\t\t\tif (!this._finished)\n\t\t\t{\n\t\t\t\tthis._partialLine = aggregate.substring(lastIndex - this._baseIndex);\n\t\t\t\tthis._baseIndex = lastIndex;\n\t\t\t}\n\n\t\t\tif (results && results.data)\n\t\t\t\tthis._rowCount += results.data.length;\n\n\t\t\tvar finishedIncludingPreview = this._finished || (this._config.preview && this._rowCount >= this._config.preview);\n\n\t\t\tif (IS_PAPA_WORKER)\n\t\t\t{\n\t\t\t\tglobal.postMessage({\n\t\t\t\t\tresults: results,\n\t\t\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\t\t\tfinished: finishedIncludingPreview\n\t\t\t\t});\n\t\t\t}\n\t\t\telse if (isFunction(this._config.chunk))\n\t\t\t{\n\t\t\t\tthis._config.chunk(results, this._handle);\n\t\t\t\tif (this._paused)\n\t\t\t\t\treturn;\n\t\t\t\tresults = undefined;\n\t\t\t\tthis._completeResults = undefined;\n\t\t\t}\n\n\t\t\tif (!this._config.step && !this._config.chunk) {\n\t\t\t\tthis._completeResults.data = this._completeResults.data.concat(results.data);\n\t\t\t\tthis._completeResults.errors = this._completeResults.errors.concat(results.errors);\n\t\t\t\tthis._completeResults.meta = results.meta;\n\t\t\t}\n\n\t\t\tif (finishedIncludingPreview && isFunction(this._config.complete) && (!results || !results.meta.aborted))\n\t\t\t\tthis._config.complete(this._completeResults, this._input);\n\n\t\t\tif (!finishedIncludingPreview && (!results || !results.meta.paused))\n\t\t\t\tthis._nextChunk();\n\n\t\t\treturn results;\n\t\t};\n\n\t\tthis._sendError = function(error)\n\t\t{\n\t\t\tif (isFunction(this._config.error))\n\t\t\t\tthis._config.error(error);\n\t\t\telse if (IS_PAPA_WORKER && this._config.error)\n\t\t\t{\n\t\t\t\tglobal.postMessage({\n\t\t\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\t\t\terror: error,\n\t\t\t\t\tfinished: false\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\tfunction replaceConfig(config)\n\t\t{\n\t\t\t// Deep-copy the config so we can edit it\n\t\t\tvar configCopy = copy(config);\n\t\t\tconfigCopy.chunkSize = parseInt(configCopy.chunkSize);\t// parseInt VERY important so we don't concatenate strings!\n\t\t\tif (!config.step && !config.chunk)\n\t\t\t\tconfigCopy.chunkSize = null;  // disable Range header if not streaming; bad values break IIS - see issue #196\n\t\t\tthis._handle = new ParserHandle(configCopy);\n\t\t\tthis._handle.streamer = this;\n\t\t\tthis._config = configCopy;\t// persist the copy to the caller\n\t\t}\n\t}\n\n\n\tfunction NetworkStreamer(config)\n\t{\n\t\tconfig = config || {};\n\t\tif (!config.chunkSize)\n\t\t\tconfig.chunkSize = Papa.RemoteChunkSize;\n\t\tChunkStreamer.call(this, config);\n\n\t\tvar xhr;\n\n\t\tif (IS_WORKER)\n\t\t{\n\t\t\tthis._nextChunk = function()\n\t\t\t{\n\t\t\t\tthis._readChunk();\n\t\t\t\tthis._chunkLoaded();\n\t\t\t};\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis._nextChunk = function()\n\t\t\t{\n\t\t\t\tthis._readChunk();\n\t\t\t};\n\t\t}\n\n\t\tthis.stream = function(url)\n\t\t{\n\t\t\tthis._input = url;\n\t\t\tthis._nextChunk();\t// Starts streaming\n\t\t};\n\n\t\tthis._readChunk = function()\n\t\t{\n\t\t\tif (this._finished)\n\t\t\t{\n\t\t\t\tthis._chunkLoaded();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\txhr = new XMLHttpRequest();\n\n\t\t\tif (this._config.withCredentials)\n\t\t\t{\n\t\t\t\txhr.withCredentials = this._config.withCredentials;\n\t\t\t}\n\n\t\t\tif (!IS_WORKER)\n\t\t\t{\n\t\t\t\txhr.onload = bindFunction(this._chunkLoaded, this);\n\t\t\t\txhr.onerror = bindFunction(this._chunkError, this);\n\t\t\t}\n\n\t\t\txhr.open('GET', this._input, !IS_WORKER);\n\t\t\t// Headers can only be set when once the request state is OPENED\n\t\t\tif (this._config.downloadRequestHeaders)\n\t\t\t{\n\t\t\t\tvar headers = this._config.downloadRequestHeaders;\n\n\t\t\t\tfor (var headerName in headers)\n\t\t\t\t{\n\t\t\t\t\txhr.setRequestHeader(headerName, headers[headerName]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this._config.chunkSize)\n\t\t\t{\n\t\t\t\tvar end = this._start + this._config.chunkSize - 1;\t// minus one because byte range is inclusive\n\t\t\t\txhr.setRequestHeader('Range', 'bytes='+this._start+'-'+end);\n\t\t\t\txhr.setRequestHeader('If-None-Match', 'webkit-no-cache'); // https://bugs.webkit.org/show_bug.cgi?id=82672\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\txhr.send();\n\t\t\t}\n\t\t\tcatch (err) {\n\t\t\t\tthis._chunkError(err.message);\n\t\t\t}\n\n\t\t\tif (IS_WORKER && xhr.status === 0)\n\t\t\t\tthis._chunkError();\n\t\t\telse\n\t\t\t\tthis._start += this._config.chunkSize;\n\t\t}\n\n\t\tthis._chunkLoaded = function()\n\t\t{\n\t\t\tif (xhr.readyState != 4)\n\t\t\t\treturn;\n\n\t\t\tif (xhr.status < 200 || xhr.status >= 400)\n\t\t\t{\n\t\t\t\tthis._chunkError();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._finished = !this._config.chunkSize || this._start > getFileSize(xhr);\n\t\t\tthis.parseChunk(xhr.responseText);\n\t\t}\n\n\t\tthis._chunkError = function(errorMessage)\n\t\t{\n\t\t\tvar errorText = xhr.statusText || errorMessage;\n\t\t\tthis._sendError(errorText);\n\t\t}\n\n\t\tfunction getFileSize(xhr)\n\t\t{\n\t\t\tvar contentRange = xhr.getResponseHeader('Content-Range');\n\t\t\tif (contentRange === null) { // no content range, then finish!\n\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\treturn parseInt(contentRange.substr(contentRange.lastIndexOf('/') + 1));\n\t\t}\n\t}\n\tNetworkStreamer.prototype = Object.create(ChunkStreamer.prototype);\n\tNetworkStreamer.prototype.constructor = NetworkStreamer;\n\n\n\tfunction FileStreamer(config)\n\t{\n\t\tconfig = config || {};\n\t\tif (!config.chunkSize)\n\t\t\tconfig.chunkSize = Papa.LocalChunkSize;\n\t\tChunkStreamer.call(this, config);\n\n\t\tvar reader, slice;\n\n\t\t// FileReader is better than FileReaderSync (even in worker) - see http://stackoverflow.com/q/24708649/1048862\n\t\t// But Firefox is a pill, too - see issue #76: https://github.com/mholt/PapaParse/issues/76\n\t\tvar usingAsyncReader = typeof FileReader !== 'undefined';\t// Safari doesn't consider it a function - see issue #105\n\n\t\tthis.stream = function(file)\n\t\t{\n\t\t\tthis._input = file;\n\t\t\tslice = file.slice || file.webkitSlice || file.mozSlice;\n\n\t\t\tif (usingAsyncReader)\n\t\t\t{\n\t\t\t\treader = new FileReader();\t\t// Preferred method of reading files, even in workers\n\t\t\t\treader.onload = bindFunction(this._chunkLoaded, this);\n\t\t\t\treader.onerror = bindFunction(this._chunkError, this);\n\t\t\t}\n\t\t\telse\n\t\t\t\treader = new FileReaderSync();\t// Hack for running in a web worker in Firefox\n\n\t\t\tthis._nextChunk();\t// Starts streaming\n\t\t};\n\n\t\tthis._nextChunk = function()\n\t\t{\n\t\t\tif (!this._finished && (!this._config.preview || this._rowCount < this._config.preview))\n\t\t\t\tthis._readChunk();\n\t\t}\n\n\t\tthis._readChunk = function()\n\t\t{\n\t\t\tvar input = this._input;\n\t\t\tif (this._config.chunkSize)\n\t\t\t{\n\t\t\t\tvar end = Math.min(this._start + this._config.chunkSize, this._input.size);\n\t\t\t\tinput = slice.call(input, this._start, end);\n\t\t\t}\n\t\t\tvar txt = reader.readAsText(input, this._config.encoding);\n\t\t\tif (!usingAsyncReader)\n\t\t\t\tthis._chunkLoaded({ target: { result: txt } });\t// mimic the async signature\n\t\t}\n\n\t\tthis._chunkLoaded = function(event)\n\t\t{\n\t\t\t// Very important to increment start each time before handling results\n\t\t\tthis._start += this._config.chunkSize;\n\t\t\tthis._finished = !this._config.chunkSize || this._start >= this._input.size;\n\t\t\tthis.parseChunk(event.target.result);\n\t\t}\n\n\t\tthis._chunkError = function()\n\t\t{\n\t\t\tthis._sendError(reader.error.message);\n\t\t}\n\n\t}\n\tFileStreamer.prototype = Object.create(ChunkStreamer.prototype);\n\tFileStreamer.prototype.constructor = FileStreamer;\n\n\n\tfunction StringStreamer(config)\n\t{\n\t\tconfig = config || {};\n\t\tChunkStreamer.call(this, config);\n\n\t\tvar string;\n\t\tvar remaining;\n\t\tthis.stream = function(s)\n\t\t{\n\t\t\tstring = s;\n\t\t\tremaining = s;\n\t\t\treturn this._nextChunk();\n\t\t}\n\t\tthis._nextChunk = function()\n\t\t{\n\t\t\tif (this._finished) return;\n\t\t\tvar size = this._config.chunkSize;\n\t\t\tvar chunk = size ? remaining.substr(0, size) : remaining;\n\t\t\tremaining = size ? remaining.substr(size) : '';\n\t\t\tthis._finished = !remaining;\n\t\t\treturn this.parseChunk(chunk);\n\t\t}\n\t}\n\tStringStreamer.prototype = Object.create(StringStreamer.prototype);\n\tStringStreamer.prototype.constructor = StringStreamer;\n\n\n\tfunction ReadableStreamStreamer(config)\n\t{\n\t\tconfig = config || {};\n\n\t\tChunkStreamer.call(this, config);\n\n\t\tvar queue = [];\n\t\tvar parseOnData = true;\n\n\t\tthis.stream = function(stream)\n\t\t{\n\t\t\tthis._input = stream;\n\n\t\t\tthis._input.on('data', this._streamData);\n\t\t\tthis._input.on('end', this._streamEnd);\n\t\t\tthis._input.on('error', this._streamError);\n\t\t}\n\n\t\tthis._nextChunk = function()\n\t\t{\n\t\t\tif (queue.length)\n\t\t\t{\n\t\t\t\tthis.parseChunk(queue.shift());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tparseOnData = true;\n\t\t\t}\n\t\t}\n\n\t\tthis._streamData = bindFunction(function(chunk)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tqueue.push(typeof chunk === 'string' ? chunk : chunk.toString(this._config.encoding));\n\n\t\t\t\tif (parseOnData)\n\t\t\t\t{\n\t\t\t\t\tparseOnData = false;\n\t\t\t\t\tthis.parseChunk(queue.shift());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (error)\n\t\t\t{\n\t\t\t\tthis._streamError(error);\n\t\t\t}\n\t\t}, this);\n\n\t\tthis._streamError = bindFunction(function(error)\n\t\t{\n\t\t\tthis._streamCleanUp();\n\t\t\tthis._sendError(error.message);\n\t\t}, this);\n\n\t\tthis._streamEnd = bindFunction(function()\n\t\t{\n\t\t\tthis._streamCleanUp();\n\t\t\tthis._finished = true;\n\t\t\tthis._streamData('');\n\t\t}, this);\n\n\t\tthis._streamCleanUp = bindFunction(function()\n\t\t{\n\t\t\tthis._input.removeListener('data', this._streamData);\n\t\t\tthis._input.removeListener('end', this._streamEnd);\n\t\t\tthis._input.removeListener('error', this._streamError);\n\t\t}, this);\n\t}\n\tReadableStreamStreamer.prototype = Object.create(ChunkStreamer.prototype);\n\tReadableStreamStreamer.prototype.constructor = ReadableStreamStreamer;\n\n\n\t// Use one ParserHandle per entire CSV file or string\n\tfunction ParserHandle(_config)\n\t{\n\t\t// One goal is to minimize the use of regular expressions...\n\t\tvar FLOAT = /^\\s*-?(\\d*\\.?\\d+|\\d+\\.?\\d*)(e[-+]?\\d+)?\\s*$/i;\n\n\t\tvar self = this;\n\t\tvar _stepCounter = 0;\t// Number of times step was called (number of rows parsed)\n\t\tvar _input;\t\t\t\t// The input being parsed\n\t\tvar _parser;\t\t\t// The core parser being used\n\t\tvar _paused = false;\t// Whether we are paused or not\n\t\tvar _aborted = false;\t// Whether the parser has aborted or not\n\t\tvar _delimiterError;\t// Temporary state between delimiter detection and processing results\n\t\tvar _fields = [];\t\t// Fields are from the header row of the input, if there is one\n\t\tvar _results = {\t\t// The last results returned from the parser\n\t\t\tdata: [],\n\t\t\terrors: [],\n\t\t\tmeta: {}\n\t\t};\n\n\t\tif (isFunction(_config.step))\n\t\t{\n\t\t\tvar userStep = _config.step;\n\t\t\t_config.step = function(results)\n\t\t\t{\n\t\t\t\t_results = results;\n\n\t\t\t\tif (needsHeaderRow())\n\t\t\t\t\tprocessResults();\n\t\t\t\telse\t// only call user's step function after header row\n\t\t\t\t{\n\t\t\t\t\tprocessResults();\n\n\t\t\t\t\t// It's possbile that this line was empty and there's no row here after all\n\t\t\t\t\tif (_results.data.length === 0)\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t_stepCounter += results.data.length;\n\t\t\t\t\tif (_config.preview && _stepCounter > _config.preview)\n\t\t\t\t\t\t_parser.abort();\n\t\t\t\t\telse\n\t\t\t\t\t\tuserStep(_results, self);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t/**\n\t\t * Parses input. Most users won't need, and shouldn't mess with, the baseIndex\n\t\t * and ignoreLastRow parameters. They are used by streamers (wrapper functions)\n\t\t * when an input comes in multiple chunks, like from a file.\n\t\t */\n\t\tthis.parse = function(input, baseIndex, ignoreLastRow)\n\t\t{\n\t\t\tif (!_config.newline)\n\t\t\t\t_config.newline = guessLineEndings(input);\n\n\t\t\t_delimiterError = false;\n\t\t\tif (!_config.delimiter)\n\t\t\t{\n\t\t\t\tvar delimGuess = guessDelimiter(input, _config.newline, _config.skipEmptyLines);\n\t\t\t\tif (delimGuess.successful)\n\t\t\t\t\t_config.delimiter = delimGuess.bestDelimiter;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_delimiterError = true;\t// add error after parsing (otherwise it would be overwritten)\n\t\t\t\t\t_config.delimiter = Papa.DefaultDelimiter;\n\t\t\t\t}\n\t\t\t\t_results.meta.delimiter = _config.delimiter;\n\t\t\t}\n\t\t\telse if(isFunction(_config.delimiter))\n\t\t\t{\n\t\t\t\t_config.delimiter = _config.delimiter(input);\n\t\t\t\t_results.meta.delimiter = _config.delimiter;\n\t\t\t}\n\n\t\t\tvar parserConfig = copy(_config);\n\t\t\tif (_config.preview && _config.header)\n\t\t\t\tparserConfig.preview++;\t// to compensate for header row\n\n\t\t\t_input = input;\n\t\t\t_parser = new Parser(parserConfig);\n\t\t\t_results = _parser.parse(_input, baseIndex, ignoreLastRow);\n\t\t\tprocessResults();\n\t\t\treturn _paused ? { meta: { paused: true } } : (_results || { meta: { paused: false } });\n\t\t};\n\n\t\tthis.paused = function()\n\t\t{\n\t\t\treturn _paused;\n\t\t};\n\n\t\tthis.pause = function()\n\t\t{\n\t\t\t_paused = true;\n\t\t\t_parser.abort();\n\t\t\t_input = _input.substr(_parser.getCharIndex());\n\t\t};\n\n\t\tthis.resume = function()\n\t\t{\n\t\t\t_paused = false;\n\t\t\tself.streamer.parseChunk(_input);\n\t\t};\n\n\t\tthis.aborted = function ()\n\t\t{\n\t\t\treturn _aborted;\n\t\t};\n\n\t\tthis.abort = function()\n\t\t{\n\t\t\t_aborted = true;\n\t\t\t_parser.abort();\n\t\t\t_results.meta.aborted = true;\n\t\t\tif (isFunction(_config.complete))\n\t\t\t\t_config.complete(_results);\n\t\t\t_input = '';\n\t\t};\n\n\t\tfunction processResults()\n\t\t{\n\t\t\tif (_results && _delimiterError)\n\t\t\t{\n\t\t\t\taddError('Delimiter', 'UndetectableDelimiter', 'Unable to auto-detect delimiting character; defaulted to \\''+Papa.DefaultDelimiter+'\\'');\n\t\t\t\t_delimiterError = false;\n\t\t\t}\n\n\t\t\tif (_config.skipEmptyLines)\n\t\t\t{\n\t\t\t\tfor (var i = 0; i < _results.data.length; i++)\n\t\t\t\t\tif (_results.data[i].length === 1 && _results.data[i][0] === '')\n\t\t\t\t\t\t_results.data.splice(i--, 1);\n\t\t\t}\n\n\t\t\tif (needsHeaderRow())\n\t\t\t\tfillHeaderFields();\n\n\t\t\treturn applyHeaderAndDynamicTyping();\n\t\t}\n\n\t\tfunction needsHeaderRow()\n\t\t{\n\t\t\treturn _config.header && _fields.length === 0;\n\t\t}\n\n\t\tfunction fillHeaderFields()\n\t\t{\n\t\t\tif (!_results)\n\t\t\t\treturn;\n\t\t\tfor (var i = 0; needsHeaderRow() && i < _results.data.length; i++)\n\t\t\t\tfor (var j = 0; j < _results.data[i].length; j++)\n\t\t\t\t\t_fields.push(_results.data[i][j]);\n\t\t\t_results.data.splice(0, 1);\n\t\t}\n\n\t\tfunction shouldApplyDynamicTyping(field) {\n\t\t\t// Cache function values to avoid calling it for each row\n\t\t\tif (_config.dynamicTypingFunction && _config.dynamicTyping[field] === undefined) {\n\t\t\t\t_config.dynamicTyping[field] = _config.dynamicTypingFunction(field);\n\t\t\t}\n\t\t\treturn (_config.dynamicTyping[field] || _config.dynamicTyping) === true\n\t\t}\n\n\t\tfunction parseDynamic(field, value)\n\t\t{\n\t\t\tif (shouldApplyDynamicTyping(field))\n\t\t\t{\n\t\t\t\tif (value === 'true' || value === 'TRUE')\n\t\t\t\t\treturn true;\n\t\t\t\telse if (value === 'false' || value === 'FALSE')\n\t\t\t\t\treturn false;\n\t\t\t\telse\n\t\t\t\t\treturn tryParseFloat(value);\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\n\t\tfunction applyHeaderAndDynamicTyping()\n\t\t{\n\t\t\tif (!_results || (!_config.header && !_config.dynamicTyping))\n\t\t\t\treturn _results;\n\n\t\t\tfor (var i = 0; i < _results.data.length; i++)\n\t\t\t{\n\t\t\t\tvar row = _config.header ? {} : [];\n\n\t\t\t\tfor (var j = 0; j < _results.data[i].length; j++)\n\t\t\t\t{\n\t\t\t\t\tvar field = j;\n\t\t\t\t\tvar value = _results.data[i][j];\n\n\t\t\t\t\tif (_config.header)\n\t\t\t\t\t\tfield = j >= _fields.length ? '__parsed_extra' : _fields[j];\n\n\t\t\t\t\tvalue = parseDynamic(field, value);\n\n\t\t\t\t\tif (field === '__parsed_extra')\n\t\t\t\t\t{\n\t\t\t\t\t\trow[field] = row[field] || [];\n\t\t\t\t\t\trow[field].push(value);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\trow[field] = value;\n\t\t\t\t}\n\n\t\t\t\t_results.data[i] = row;\n\n\t\t\t\tif (_config.header)\n\t\t\t\t{\n\t\t\t\t\tif (j > _fields.length)\n\t\t\t\t\t\taddError('FieldMismatch', 'TooManyFields', 'Too many fields: expected ' + _fields.length + ' fields but parsed ' + j, i);\n\t\t\t\t\telse if (j < _fields.length)\n\t\t\t\t\t\taddError('FieldMismatch', 'TooFewFields', 'Too few fields: expected ' + _fields.length + ' fields but parsed ' + j, i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (_config.header && _results.meta)\n\t\t\t\t_results.meta.fields = _fields;\n\t\t\treturn _results;\n\t\t}\n\n\t\tfunction guessDelimiter(input, newline, skipEmptyLines)\n\t\t{\n\t\t\tvar delimChoices = [',', '\\t', '|', ';', Papa.RECORD_SEP, Papa.UNIT_SEP];\n\t\t\tvar bestDelim, bestDelta, fieldCountPrevRow;\n\n\t\t\tfor (var i = 0; i < delimChoices.length; i++)\n\t\t\t{\n\t\t\t\tvar delim = delimChoices[i];\n\t\t\t\tvar delta = 0, avgFieldCount = 0, emptyLinesCount = 0;\n\t\t\t\tfieldCountPrevRow = undefined;\n\n\t\t\t\tvar preview = new Parser({\n\t\t\t\t\tdelimiter: delim,\n\t\t\t\t\tnewline: newline,\n\t\t\t\t\tpreview: 10\n\t\t\t\t}).parse(input);\n\n\t\t\t\tfor (var j = 0; j < preview.data.length; j++)\n\t\t\t\t{\n\t\t\t\t\tif (skipEmptyLines && preview.data[j].length === 1 && preview.data[j][0].length === 0) {\n\t\t\t\t\t\temptyLinesCount++\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tvar fieldCount = preview.data[j].length;\n\t\t\t\t\tavgFieldCount += fieldCount;\n\n\t\t\t\t\tif (typeof fieldCountPrevRow === 'undefined')\n\t\t\t\t\t{\n\t\t\t\t\t\tfieldCountPrevRow = fieldCount;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if (fieldCount > 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tdelta += Math.abs(fieldCount - fieldCountPrevRow);\n\t\t\t\t\t\tfieldCountPrevRow = fieldCount;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (preview.data.length > 0)\n\t\t\t\t\tavgFieldCount /= (preview.data.length - emptyLinesCount);\n\n\t\t\t\tif ((typeof bestDelta === 'undefined' || delta < bestDelta)\n\t\t\t\t\t&& avgFieldCount > 1.99)\n\t\t\t\t{\n\t\t\t\t\tbestDelta = delta;\n\t\t\t\t\tbestDelim = delim;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_config.delimiter = bestDelim;\n\n\t\t\treturn {\n\t\t\t\tsuccessful: !!bestDelim,\n\t\t\t\tbestDelimiter: bestDelim\n\t\t\t}\n\t\t}\n\n\t\tfunction guessLineEndings(input)\n\t\t{\n\t\t\tinput = input.substr(0, 1024*1024);\t// max length 1 MB\n\n\t\t\tvar r = input.split('\\r');\n\n\t\t\tvar n = input.split('\\n');\n\n\t\t\tvar nAppearsFirst = (n.length > 1 && n[0].length < r[0].length);\n\n\t\t\tif (r.length === 1 || nAppearsFirst)\n\t\t\t\treturn '\\n';\n\n\t\t\tvar numWithN = 0;\n\t\t\tfor (var i = 0; i < r.length; i++)\n\t\t\t{\n\t\t\t\tif (r[i][0] === '\\n')\n\t\t\t\t\tnumWithN++;\n\t\t\t}\n\n\t\t\treturn numWithN >= r.length / 2 ? '\\r\\n' : '\\r';\n\t\t}\n\n\t\tfunction tryParseFloat(val)\n\t\t{\n\t\t\tvar isNumber = FLOAT.test(val);\n\t\t\treturn isNumber ? parseFloat(val) : val;\n\t\t}\n\n\t\tfunction addError(type, code, msg, row)\n\t\t{\n\t\t\t_results.errors.push({\n\t\t\t\ttype: type,\n\t\t\t\tcode: code,\n\t\t\t\tmessage: msg,\n\t\t\t\trow: row\n\t\t\t});\n\t\t}\n\t}\n\n\n\n\n\n\t/** The core parser implements speedy and correct CSV parsing */\n\tfunction Parser(config)\n\t{\n\t\t// Unpack the config object\n\t\tconfig = config || {};\n\t\tvar delim = config.delimiter;\n\t\tvar newline = config.newline;\n\t\tvar comments = config.comments;\n\t\tvar step = config.step;\n\t\tvar preview = config.preview;\n\t\tvar fastMode = config.fastMode;\n\t\t/** Allows for no quoteChar by setting quoteChar to undefined in config */\n\t\tif (config.quoteChar === undefined){\n\t\t\tvar quoteChar = '\"';\n\t\t} else {\n\t\t\tvar quoteChar = config.quoteChar;\n\t\t}\n\n\t\t// Delimiter must be valid\n\t\tif (typeof delim !== 'string'\n\t\t\t|| Papa.BAD_DELIMITERS.indexOf(delim) > -1)\n\t\t\tdelim = ',';\n\n\t\t// Comment character must be valid\n\t\tif (comments === delim)\n\t\t\tthrow 'Comment character same as delimiter';\n\t\telse if (comments === true)\n\t\t\tcomments = '#';\n\t\telse if (typeof comments !== 'string'\n\t\t\t|| Papa.BAD_DELIMITERS.indexOf(comments) > -1)\n\t\t\tcomments = false;\n\n\t\t// Newline must be valid: \\r, \\n, or \\r\\n\n\t\tif (newline != '\\n' && newline != '\\r' && newline != '\\r\\n')\n\t\t\tnewline = '\\n';\n\n\t\t// We're gonna need these at the Parser scope\n\t\tvar cursor = 0;\n\t\tvar aborted = false;\n\n\t\tthis.parse = function(input, baseIndex, ignoreLastRow)\n\t\t{\n\t\t\t// For some reason, in Chrome, this speeds things up (!?)\n\t\t\tif (typeof input !== 'string')\n\t\t\t\tthrow 'Input must be a string';\n\n\t\t\t// We don't need to compute some of these every time parse() is called,\n\t\t\t// but having them in a more local scope seems to perform better\n\t\t\tvar inputLen = input.length,\n\t\t\t\tdelimLen = delim.length,\n\t\t\t\tnewlineLen = newline.length,\n\t\t\t\tcommentsLen = comments.length;\n\t\t\tvar stepIsFunction = isFunction(step);\n\n\t\t\t// Establish starting state\n\t\t\tcursor = 0;\n\t\t\tvar data = [], errors = [], row = [], lastCursor = 0;\n\n\t\t\tif (!input)\n\t\t\t\treturn returnable();\n\n\t\t\tif (fastMode || (fastMode !== false && input.indexOf(quoteChar) === -1))\n\t\t\t{\n\t\t\t\tvar rows = input.split(newline);\n\t\t\t\tfor (var i = 0; i < rows.length; i++)\n\t\t\t\t{\n\t\t\t\t\tvar row = rows[i];\n\t\t\t\t\tcursor += row.length;\n\t\t\t\t\tif (i !== rows.length - 1)\n\t\t\t\t\t\tcursor += newline.length;\n\t\t\t\t\telse if (ignoreLastRow)\n\t\t\t\t\t\treturn returnable();\n\t\t\t\t\tif (comments && row.substr(0, commentsLen) === comments)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (stepIsFunction)\n\t\t\t\t\t{\n\t\t\t\t\t\tdata = [];\n\t\t\t\t\t\tpushRow(row.split(delim));\n\t\t\t\t\t\tdoStep();\n\t\t\t\t\t\tif (aborted)\n\t\t\t\t\t\t\treturn returnable();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tpushRow(row.split(delim));\n\t\t\t\t\tif (preview && i >= preview)\n\t\t\t\t\t{\n\t\t\t\t\t\tdata = data.slice(0, preview);\n\t\t\t\t\t\treturn returnable(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn returnable();\n\t\t\t}\n\n\t\t\tvar nextDelim = input.indexOf(delim, cursor);\n\t\t\tvar nextNewline = input.indexOf(newline, cursor);\n\t\t\tvar quoteCharRegex = new RegExp(quoteChar+quoteChar, 'g');\n\n\t\t\t// Parser loop\n\t\t\tfor (;;)\n\t\t\t{\n\t\t\t\t// Field has opening quote\n\t\t\t\tif (input[cursor] === quoteChar)\n\t\t\t\t{\n\t\t\t\t\t// Start our search for the closing quote where the cursor is\n\t\t\t\t\tvar quoteSearch = cursor;\n\n\t\t\t\t\t// Skip the opening quote\n\t\t\t\t\tcursor++;\n\n\t\t\t\t\tfor (;;)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Find closing quote\n\t\t\t\t\t\tvar quoteSearch = input.indexOf(quoteChar, quoteSearch+1);\n\n\t\t\t\t\t\t//No other quotes are found - no other delimiters\n\t\t\t\t\t\tif (quoteSearch === -1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!ignoreLastRow) {\n\t\t\t\t\t\t\t\t// No closing quote... what a pity\n\t\t\t\t\t\t\t\terrors.push({\n\t\t\t\t\t\t\t\t\ttype: 'Quotes',\n\t\t\t\t\t\t\t\t\tcode: 'MissingQuotes',\n\t\t\t\t\t\t\t\t\tmessage: 'Quoted field unterminated',\n\t\t\t\t\t\t\t\t\trow: data.length,\t// row has yet to be inserted\n\t\t\t\t\t\t\t\t\tindex: cursor\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn finish();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Closing quote at EOF\n\t\t\t\t\t\tif (quoteSearch === inputLen-1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar value = input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar);\n\t\t\t\t\t\t\treturn finish(value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If this quote is escaped, it's part of the data; skip it\n\t\t\t\t\t\tif (input[quoteSearch+1] === quoteChar)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tquoteSearch++;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Closing quote followed by delimiter\n\t\t\t\t\t\tif (input[quoteSearch+1] === delim)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trow.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));\n\t\t\t\t\t\t\tcursor = quoteSearch + 1 + delimLen;\n\t\t\t\t\t\t\tnextDelim = input.indexOf(delim, cursor);\n\t\t\t\t\t\t\tnextNewline = input.indexOf(newline, cursor);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Closing quote followed by newline\n\t\t\t\t\t\tif (input.substr(quoteSearch+1, newlineLen) === newline)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trow.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));\n\t\t\t\t\t\t\tsaveRow(quoteSearch + 1 + newlineLen);\n\t\t\t\t\t\t\tnextDelim = input.indexOf(delim, cursor);\t// because we may have skipped the nextDelim in the quoted field\n\n\t\t\t\t\t\t\tif (stepIsFunction)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdoStep();\n\t\t\t\t\t\t\t\tif (aborted)\n\t\t\t\t\t\t\t\t\treturn returnable();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (preview && data.length >= preview)\n\t\t\t\t\t\t\t\treturn returnable(true);\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t// Checks for valid closing quotes are complete (escaped quotes or quote followed by EOF/delimiter/newline) -- assume these quotes are part of an invalid text string\n\t\t\t\t\t\terrors.push({\n\t\t\t\t\t\t\ttype: 'Quotes',\n\t\t\t\t\t\t\tcode: 'InvalidQuotes',\n\t\t\t\t\t\t\tmessage: 'Trailing quote on quoted field is malformed',\n\t\t\t\t\t\t\trow: data.length,\t// row has yet to be inserted\n\t\t\t\t\t\t\tindex: cursor\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tquoteSearch++;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Comment found at start of new line\n\t\t\t\tif (comments && row.length === 0 && input.substr(cursor, commentsLen) === comments)\n\t\t\t\t{\n\t\t\t\t\tif (nextNewline === -1)\t// Comment ends at EOF\n\t\t\t\t\t\treturn returnable();\n\t\t\t\t\tcursor = nextNewline + newlineLen;\n\t\t\t\t\tnextNewline = input.indexOf(newline, cursor);\n\t\t\t\t\tnextDelim = input.indexOf(delim, cursor);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Next delimiter comes before next newline, so we've reached end of field\n\t\t\t\tif (nextDelim !== -1 && (nextDelim < nextNewline || nextNewline === -1))\n\t\t\t\t{\n\t\t\t\t\trow.push(input.substring(cursor, nextDelim));\n\t\t\t\t\tcursor = nextDelim + delimLen;\n\t\t\t\t\tnextDelim = input.indexOf(delim, cursor);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// End of row\n\t\t\t\tif (nextNewline !== -1)\n\t\t\t\t{\n\t\t\t\t\trow.push(input.substring(cursor, nextNewline));\n\t\t\t\t\tsaveRow(nextNewline + newlineLen);\n\n\t\t\t\t\tif (stepIsFunction)\n\t\t\t\t\t{\n\t\t\t\t\t\tdoStep();\n\t\t\t\t\t\tif (aborted)\n\t\t\t\t\t\t\treturn returnable();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (preview && data.length >= preview)\n\t\t\t\t\t\treturn returnable(true);\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\n\t\t\treturn finish();\n\n\n\t\t\tfunction pushRow(row)\n\t\t\t{\n\t\t\t\tdata.push(row);\n\t\t\t\tlastCursor = cursor;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Appends the remaining input from cursor to the end into\n\t\t\t * row, saves the row, calls step, and returns the results.\n\t\t\t */\n\t\t\tfunction finish(value)\n\t\t\t{\n\t\t\t\tif (ignoreLastRow)\n\t\t\t\t\treturn returnable();\n\t\t\t\tif (typeof value === 'undefined')\n\t\t\t\t\tvalue = input.substr(cursor);\n\t\t\t\trow.push(value);\n\t\t\t\tcursor = inputLen;\t// important in case parsing is paused\n\t\t\t\tpushRow(row);\n\t\t\t\tif (stepIsFunction)\n\t\t\t\t\tdoStep();\n\t\t\t\treturn returnable();\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Appends the current row to the results. It sets the cursor\n\t\t\t * to newCursor and finds the nextNewline. The caller should\n\t\t\t * take care to execute user's step function and check for\n\t\t\t * preview and end parsing if necessary.\n\t\t\t */\n\t\t\tfunction saveRow(newCursor)\n\t\t\t{\n\t\t\t\tcursor = newCursor;\n\t\t\t\tpushRow(row);\n\t\t\t\trow = [];\n\t\t\t\tnextNewline = input.indexOf(newline, cursor);\n\t\t\t}\n\n\t\t\t/** Returns an object with the results, errors, and meta. */\n\t\t\tfunction returnable(stopped)\n\t\t\t{\n\t\t\t\treturn {\n\t\t\t\t\tdata: data,\n\t\t\t\t\terrors: errors,\n\t\t\t\t\tmeta: {\n\t\t\t\t\t\tdelimiter: delim,\n\t\t\t\t\t\tlinebreak: newline,\n\t\t\t\t\t\taborted: aborted,\n\t\t\t\t\t\ttruncated: !!stopped,\n\t\t\t\t\t\tcursor: lastCursor + (baseIndex || 0)\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t/** Executes the user's step function and resets data & errors. */\n\t\t\tfunction doStep()\n\t\t\t{\n\t\t\t\tstep(returnable());\n\t\t\t\tdata = [], errors = [];\n\t\t\t}\n\t\t};\n\n\t\t/** Sets the abort flag */\n\t\tthis.abort = function()\n\t\t{\n\t\t\taborted = true;\n\t\t};\n\n\t\t/** Gets the cursor position */\n\t\tthis.getCharIndex = function()\n\t\t{\n\t\t\treturn cursor;\n\t\t};\n\t}\n\n\n\t// If you need to load Papa Parse asynchronously and you also need worker threads, hard-code\n\t// the script path here. See: https://github.com/mholt/PapaParse/issues/87#issuecomment-57885358\n\tfunction getScriptPath()\n\t{\n\t\tvar scripts = document.getElementsByTagName('script');\n\t\treturn scripts.length ? scripts[scripts.length - 1].src : '';\n\t}\n\n\tfunction newWorker()\n\t{\n\t\tif (!Papa.WORKERS_SUPPORTED)\n\t\t\treturn false;\n\t\tif (!LOADED_SYNC && Papa.SCRIPT_PATH === null)\n\t\t\tthrow new Error(\n\t\t\t\t'Script path cannot be determined automatically when Papa Parse is loaded asynchronously. ' +\n\t\t\t\t'You need to set Papa.SCRIPT_PATH manually.'\n\t\t\t);\n\t\tvar workerUrl = Papa.SCRIPT_PATH || AUTO_SCRIPT_PATH;\n\t\t// Append 'papaworker' to the search string to tell papaparse that this is our worker.\n\t\tworkerUrl += (workerUrl.indexOf('?') !== -1 ? '&' : '?') + 'papaworker';\n\t\tvar w = new global.Worker(workerUrl);\n\t\tw.onmessage = mainThreadReceivedMessage;\n\t\tw.id = workerIdCounter++;\n\t\tworkers[w.id] = w;\n\t\treturn w;\n\t}\n\n\t/** Callback when main thread receives a message */\n\tfunction mainThreadReceivedMessage(e)\n\t{\n\t\tvar msg = e.data;\n\t\tvar worker = workers[msg.workerId];\n\t\tvar aborted = false;\n\n\t\tif (msg.error)\n\t\t\tworker.userError(msg.error, msg.file);\n\t\telse if (msg.results && msg.results.data)\n\t\t{\n\t\t\tvar abort = function() {\n\t\t\t\taborted = true;\n\t\t\t\tcompleteWorker(msg.workerId, { data: [], errors: [], meta: { aborted: true } });\n\t\t\t};\n\n\t\t\tvar handle = {\n\t\t\t\tabort: abort,\n\t\t\t\tpause: notImplemented,\n\t\t\t\tresume: notImplemented\n\t\t\t};\n\n\t\t\tif (isFunction(worker.userStep))\n\t\t\t{\n\t\t\t\tfor (var i = 0; i < msg.results.data.length; i++)\n\t\t\t\t{\n\t\t\t\t\tworker.userStep({\n\t\t\t\t\t\tdata: [msg.results.data[i]],\n\t\t\t\t\t\terrors: msg.results.errors,\n\t\t\t\t\t\tmeta: msg.results.meta\n\t\t\t\t\t}, handle);\n\t\t\t\t\tif (aborted)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdelete msg.results;\t// free memory ASAP\n\t\t\t}\n\t\t\telse if (isFunction(worker.userChunk))\n\t\t\t{\n\t\t\t\tworker.userChunk(msg.results, handle, msg.file);\n\t\t\t\tdelete msg.results;\n\t\t\t}\n\t\t}\n\n\t\tif (msg.finished && !aborted)\n\t\t\tcompleteWorker(msg.workerId, msg.results);\n\t}\n\n\tfunction completeWorker(workerId, results) {\n\t\tvar worker = workers[workerId];\n\t\tif (isFunction(worker.userComplete))\n\t\t\tworker.userComplete(results);\n\t\tworker.terminate();\n\t\tdelete workers[workerId];\n\t}\n\n\tfunction notImplemented() {\n\t\tthrow 'Not implemented.';\n\t}\n\n\t/** Callback when worker thread receives a message */\n\tfunction workerThreadReceivedMessage(e)\n\t{\n\t\tvar msg = e.data;\n\n\t\tif (typeof Papa.WORKER_ID === 'undefined' && msg)\n\t\t\tPapa.WORKER_ID = msg.workerId;\n\n\t\tif (typeof msg.input === 'string')\n\t\t{\n\t\t\tglobal.postMessage({\n\t\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\t\tresults: Papa.parse(msg.input, msg.config),\n\t\t\t\tfinished: true\n\t\t\t});\n\t\t}\n\t\telse if ((global.File && msg.input instanceof File) || msg.input instanceof Object)\t// thank you, Safari (see issue #106)\n\t\t{\n\t\t\tvar results = Papa.parse(msg.input, msg.config);\n\t\t\tif (results)\n\t\t\t\tglobal.postMessage({\n\t\t\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\t\t\tresults: results,\n\t\t\t\t\tfinished: true\n\t\t\t\t});\n\t\t}\n\t}\n\n\t/** Makes a deep copy of an array or object (mostly) */\n\tfunction copy(obj)\n\t{\n\t\tif (typeof obj !== 'object')\n\t\t\treturn obj;\n\t\tvar cpy = obj instanceof Array ? [] : {};\n\t\tfor (var key in obj)\n\t\t\tcpy[key] = copy(obj[key]);\n\t\treturn cpy;\n\t}\n\n\tfunction bindFunction(f, self)\n\t{\n\t\treturn function() { f.apply(self, arguments); };\n\t}\n\n\tfunction isFunction(func)\n\t{\n\t\treturn typeof func === 'function';\n\t}\n\n\treturn Papa;\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/papaparse/papaparse.js\n// module id = 338\n// module chunks = 272379572042316","import React from 'react';\nimport Link from 'gatsby-link';\nimport styled from 'styled-components';\nimport Papa from 'papaparse';\n\nimport { Container, Content, Title, TitleWrapper } from '../components/styled';\n\nexport default ({ data }) => {\n  const { edges: books } = data.allBooksCsv;\n\n  const booksArr = books.map(item => {\n    const node = item.node;\n    return {\n      author: node.author,\n      book: node.book,\n      cover: node.cover,\n      favorite: node.favorite.toLowerCase() === \"true\",\n      genre: node.genre.split(\",\"),\n      isbn: parseInt(node.isbn, 10),\n      pages: parseInt(node.pages, 10),\n    };\n  });\n\n  return (\n    <Container>\n      <TitleWrapper>\n        <Title>Playground</Title>\n        <div id=\"chart\" />\n      </TitleWrapper>\n      <Content>\n      </Content>\n    </Container>\n  );\n};\n\nexport const booksQuery = graphql`\n  query allBooks {\n    allBooksCsv {\n        edges {\n          node {\n            book\n            rating\n            cover\n            author\n            pages\n            genre\n            isbn\n            favorite\n          }\n        }\n      }\n  }\n`;\n\n\n\n// WEBPACK FOOTER //\n// ./src/pages/playground.js"],"sourceRoot":""}
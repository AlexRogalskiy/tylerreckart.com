<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><style data-href="/component---src-templates-post-js.ffef6564d06d07767334.css">html{-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;font-family:sans-serif}body{font-family:IBM Plex Sans,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Helvetica,sans-serif;font-size:14px;height:100%;letter-spacing:.025em;line-height:22px;margin:0}*{-webkit-box-sizing:border-box;box-sizing:border-box}code{font-family:Space Mono,Menlo,Monaco,Courier New,monospace!important;font-size:95%;line-height:22px}a{border-bottom:1px dotted #00f;color:#00f;text-decoration:none}a:hover{border-bottom:1px solid #00f}div.blog-post-content>p:last-of-type{padding-bottom:0}
code[class*=language-],pre[class*=language-]{-moz-hyphens:none;-moz-tab-size:2;-ms-hyphens:none;-o-tab-size:2;-webkit-hyphens:none;color:#abcdfd;font-size:14px;hyphens:none;tab-size:2;text-shadow:none;white-space:pre;white-space:pre-wrap;word-wrap:normal}:not(pre)>code[class*=language-],pre[class*=language-]{background:#1a1a26}pre[class*=language-]{border-radius:4px;overflow:auto;padding:18px;position:relative}pre[class*=language-] code{display:block;white-space:pre}:not(pre)>code[class*=language-]{border-radius:.3em;padding:.15em .2em .05em}.token.namespace{opacity:.7}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#60637f}.token.boolean,.token.number,.token.operator{color:#c094e9}.language-css .token.string,.style .token.string,.token.attr-name,.token.entity,.token.string,.token.url{color:#e6d06c}.token.inserted,.token.selector{color:#a6e22d}.token.atrule,.token.attr-value,.token.deleted,.token.important,.token.keyword{color:#ef3b7d}.token.regex,.token.statement{color:#76d9e6}.token.placeholder,.token.variable{color:#fff}.token.bold,.token.important,.token.statement{font-weight:700}.token.punctuation{color:#bebec5}.token.entity{cursor:help}.token.italic{font-style:italic}code.language-markup{color:#f9f9f9}code.language-markup .token.tag{color:#ef3b7d}code.language-markup .token.attr-name{color:#a6e22d}code.language-markup .token.attr-value{color:#e6d06c}code.language-markup .token.script,code.language-markup .token.script .token.keyword,code.language-markup .token.style{color:#a6c1e3}pre[class*=language-][data-line]{padding:1em 0 1em 3em;position:relative}pre[data-line] .line-highlight{background:hsla(0,0%,100%,.08);left:0;line-height:inherit;margin-top:1em;padding:0;pointer-events:none;position:absolute;right:0;white-space:pre}pre[data-line] .line-highlight:before,pre[data-line] .line-highlight[data-end]:after{background-color:hsla(0,0%,100%,.4);border-radius:999px;color:#000;content:attr(data-start);font:700 65%/1 sans-serif;height:1em;left:.6em;line-height:1em;min-width:1em;padding:.2em .5em;position:absolute;text-align:center;text-shadow:none;top:.4em}pre[data-line] .line-highlight[data-end]:after{bottom:.4em;content:attr(data-end);top:auto}

/*# sourceMappingURL=component---src-templates-post-js.ffef6564d06d07767334.css.map*/</style><title data-react-helmet="true">Tyler Reckart - Type Level Programming: Part 1</title><link data-react-helmet="true" href="https://fonts.googleapis.com/css?family=Space+Mono" rel="stylesheet"/><link data-react-helmet="true" href="https://fonts.googleapis.com/css?family=IBM+Plex+Sans:400,700" rel="stylesheet"/><meta data-react-helmet="true" name="description" content="Sample"/><meta data-react-helmet="true" name="keywords" content="sample, something"/><style type="text/css" data-styled-components="iDBAbg iUCiDQ cifout idbuRr iSErpD ioCyAh jhYonK knpirl fqUZCc gaNZuR beYwGw cMeLzD" data-styled-components-is-local="true">/* sc-component-id: Header-sc-1txdy0l-0 */

.iDBAbg{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;margin:4em auto;max-width:700px;}.iDBAbg a{text-decoration:none;border-bottom:none;}.iDBAbg a:hover{border-bottom:none;}
/* sc-component-id: Footer-sc-1rthzzu-0 */

.idbuRr{color:#8194A4;font-size:12px;margin:4em 0;}
/* sc-component-id: Sidebar-b62msq-0 */

.cifout{font-size:14px;max-width:700px !important;}.cifout p{margin:0 0 .2em 0;}.cifout ul{list-style:none;margin:0;padding:0;}.cifout ul li{margin-bottom:0.25em;}.cifout h4{margin:2em 0 .25em 0;}.cifout .intro{margin:0 0 2em 0;}.cifout .hr{display:none;text-align:center;margin-bottom:2em;}.cifout .hr{display:block;}
/* sc-component-id: layout__Template-udz7ve-0 */

.iUCiDQ{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column-reverse;-ms-flex-direction:column-reverse;flex-direction:column-reverse;-webkit-align-items:flex-start;-webkit-box-align:flex-start;-ms-flex-align:flex-start;align-items:flex-start;max-width:700px;margin:0 auto;}
/* sc-component-id: styled__Container-g21d3b-0 */

@media (max-width:700px){.iSErpD{margin:0 1em;}}.iSErpD div{margin:0 auto;max-width:800px;}.iSErpD p{padding:0 1em;}@media (max-width:700px){.iSErpD p{padding:0;}}
/* sc-component-id: styled__Content-g21d3b-1 */

.beYwGw{font-size:14px;font-weight:400;line-height:30px;max-width:700px;}.beYwGw div.blog-post-content > p:last-of-type{background-color:red;padding-bottom:0;}.beYwGw p{max-width:700px;margin:0 auto;padding:.75em 0;overflow:visible;}.beYwGw p code{color:#ef3b7d !important;font-weight:300;background-color:#fff !important;padding:0 4px 1px 4px !important;}.beYwGw p img{width:100%;}.beYwGw .gatsby-resp-image-link{border:none;}.beYwGw sup{font-family:sans-serif;font-size:10px;}@media (max-width:1040px){.beYwGw a.gatsby-resp-image-link{min-width:760px;-webkit-transform:translateX(42%);-ms-transform:translateX(42%);transform:translateX(42%);}}@media (max-width:800px){.beYwGw a.gatsby-resp-image-link{min-width:100%;positon:static;left:0%;-webkit-transform:translateX(0%);-ms-transform:translateX(0%);transform:translateX(0%);}}.beYwGw hr{max-width:700px;margin:0 auto;height:1px;border:none;display:block;background-color:rgba(220,222,222,1.00);margin:1em auto 1em auto;}.beYwGw ul{max-width:700px;margin:0 auto;padding:0 20px;}.beYwGw ol{max-width:700px;margin:0 auto;padding:0 20px;}.beYwGw ol li{padding-left:20px;}.beYwGw blockquote p{border-left:1px dotted #0000EE;font-style:italic;padding-left:20px;}.beYwGw blockquote p span{font-size:12px;color:#8194A4;}.beYwGw pre{max-width:700px;margin:0 auto;}.beYwGw h1,.beYwGw h2,.beYwGw h3,.beYwGw h4,.beYwGw h5,.beYwGw h6{max-width:700px;margin:0 auto;}
/* sc-component-id: styled__Date-g21d3b-2 */

.knpirl{font-size:14px !important;color:#8194A4;font-weight:300;margin:0;padding:0;display:inline;margin:0 0 0 0.5em;}.knpirl a{color:#ef3b7d;padding:0 8px;}
/* sc-component-id: styled__HomeLink-g21d3b-3 */

.gaNZuR{font-size:14px;font-weight:400;margin:0;padding:0;display:inline;}
/* sc-component-id: styled__Title-g21d3b-5 */

.jhYonK{font-size:14px !important;font-weight:bold;-webkit-letter-spacing:0.01em;-moz-letter-spacing:0.01em;-ms-letter-spacing:0.01em;letter-spacing:0.01em;padding:0;display:inline;}
/* sc-component-id: styled__TitleWrapper-g21d3b-6 */

.ioCyAh{max-width:700px !important;margin:0 auto !important;}
/* sc-component-id: styled__TimeToRead-g21d3b-7 */

.fqUZCc{display:inline;color:#8194A4;font-size:14px;}
/* sc-component-id: post__Comments-sc-48ualj-0 */

.cMeLzD{max-width:700px !important;margin:0 auto;margin-top:1em !important;margin-bottom:2em !important;}@media (max-width:700px){.cMeLzD{padding:0;}}
</style><link rel="icon" type="image/png" sizes="16x16" href="/icons-5188e9cd133362e349708cd3c859a6d2/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/icons-5188e9cd133362e349708cd3c859a6d2/favicon-32x32.png"/><link rel="shortcut icon" href="/icons-5188e9cd133362e349708cd3c859a6d2/favicon.ico"/><link as="script" rel="preload" href="/component---src-templates-post-js-5142991cc9c82a431204.js"/><link as="script" rel="preload" href="/app-40ef773447651335202c.js"/><link as="script" rel="preload" href="/1-5a707e09b8f49b2b05ae.js"/><link as="script" rel="preload" href="/0-288ed6b0962aa8bad9c0.js"/><link as="script" rel="preload" href="/webpack-runtime-b145ddd9c3709fa1e1bf.js"/><link rel="preload" href="/static/d/284/path---2018-04-10-type-level-programming-part-1-ecf-21f-bTp74uLXUHKFYeP8zVSoHkU1Vq0.json" as="fetch" crossOrigin="use-credentials"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" role="group"><div><header class="Header-sc-1txdy0l-0 iDBAbg"><a href="/"><img src="/static/party-wizard-5188e9cd133362e349708cd3c859a6d2.gif" width="16px" height="16px"/></a></header><div class="layout__Template-udz7ve-0 iUCiDQ"><div class="sidebar Sidebar-b62msq-0 cifout"><div class="hr">***</div><div class="intro"><p>I&#x27;m <strong>Tyler Reckart</strong>; a <a href="https://github.com/tylerreckart" target="_blank">software developer</a>, <a href="https://dribbble.com/tylerreckart" target="_blank">occasional designer</a>, and watch geek.</p></div><nav><ul><li>üè† <a href="/">Home</a> </li><li>üìñ <a href="/about">About</a> </li><li>üë®‚Äçüíª <a href="https://github.com/tylerreckart" target="_blank">Github</a></li><li>üê£ <a href="https://twitter.com/tylerreckart" target="_blank">@tylerreckart</a></li></ul></nav><h4>Projects</h4><ul><li><a href="https://www.manning.com/livevideo/graphql-in-motion" target="_blank">GraphQL In Motion</a>, a comprehensive video course that covers the fundementals of building, deploying, and scaling a GraphQL API.</li><li><a href="https://github.com/tylerreckart/hyperzsh" target="_blank">Hyperzsh</a>, a z shell theme designed to complement a git-focused workflow.</li></ul><footer class="Footer-sc-1rthzzu-0 idbuRr"><p>¬© 2013-2018 Tyler Reckart. All Rights Reserved.</p></footer></div><div style="margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:800px;position:relative"><div class="styled__Container-g21d3b-0 iSErpD"><div class="styled__TitleWrapper-g21d3b-6 ioCyAh" style="display:flex;justify-content:space-between"><div style="margin:0"><h2 class="styled__Title-g21d3b-5 jhYonK">Type Level Programming: Part 1</h2><h3 class="styled__Date-g21d3b-2 knpirl">April 10th 2018</h3><div class="styled__TimeToRead-g21d3b-7 fqUZCc"> ‚òïÔ∏è 6 min read</div></div><h3 class="styled__HomeLink-g21d3b-3 gaNZuR"><a href="/">‚Üê Go Back</a></h3></div><div class="blog-post-content styled__Content-g21d3b-1 beYwGw"><p>As tools and methodologies for software development have evolved, the functional programming paradigm has washed over the tools we use across the stack.  Haskell has been a <a href="https://github.com/BinRoot/Haskell-Data-Analysis-Cookbook">go-to tool for developers to use for data analysis</a> for close to three decades. On the other end, languages like <a href="https://www.typescriptlang.org/">TypeScript</a> and <a href="http://elm-lang.org/">Elm</a> have hit the front-end landscape like a wave. Thus allowing developers to develop type-safe applications that compile to browser-readable JavaScript. You've probably heard functional programming advocates discussing all the benefits of these tools and what you can do by putting more information into a type system. And well, they're right. On the front end, if you look closely, you can see <a href="https://redux.js.org/introduction/prior-art#elm">how languages like Elm influenced the architecture libraries like Redux</a>.</p>
<p>Statically-typed programming languages give you more control over how you build software.</p>
<p>As a note, I'm not going to spend time covering basic types and primitives here. Understanding higher kinded and dynamically kinded types requires a solid understanding of Haskell's underlying basic type system and their primitives. If you don't have that foundation, this may not be the right article for you. It may end up being more confusing than helpful.</p>
<h3>The Higher Kinds</h3>
<p>As a quick refresher, at its core, a type is a way of classifying <em>things</em>. We assign types to functions and use them to compare a function's declared type and the values it returns. So, how do we define types in Haskell? If you're not already aware, a <a href="http://learnyouahaskell.com/making-our-own-types-and-typeclasses">value constructor accepts a value and yields a value</a>. In a similar manner, a type constructor accepts a type and yields a type.</p>
<div class="gatsby-highlight" data-language="haskell"><pre class="language-haskell"><code class="language-haskell">data Maybe a
  = Just a
  | Nothing</code></pre></div>
<p>Above, we declare a type <strong>Maybe</strong> that consists of two data constructors. <strong>Just</strong>, which accepts a value of type a, and <strong>Nothing</strong>, which does not accept any values at all. However, before we go any further, let's discuss those data constructors a bit more in depth.</p>
<div class="gatsby-highlight" data-language="haskell"><pre class="language-haskell"><code class="language-haskell">ghci&gt; :t Just
Just :: a -&gt; Maybe a
ghci&gt; :t Nothing
Nothing :: Maybe a</code></pre></div>
<p><strong>Just</strong> has a function type. This means that any value we give it will become a <strong>Maybe</strong> of that type. <strong>Nothing</strong>, however, can conjure up whatever type it wants without needing a value at all. This pattern is actually pretty common, and when we declare a type <code class="language-text">Nothing :: Maybe a</code>, what we're actually saying is that <strong>Nothing</strong> is. value of <strong>Maybe a</strong> for any and all types <strong>a</strong> that may be provided to it.</p>
<p>Armed with that knowledge, you might be driven to ask: what is the type of <strong>Maybe</strong>?</p>
<div class="gatsby-highlight" data-language="haskell"><pre class="language-haskell"><code class="language-haskell">ghci&gt; :t Maybe

\&lt;interactive\&gt;:1:1: error:
  ‚Ä¢ Data constructor not in scope: Maybe
  ‚Ä¢ Perhaps you meant variable ‚Äòmaybe‚Äô (imported from Prelude)</code></pre></div>
<p>Hold on a second. What's going on here? Does this mean that types don't have types of their own? Well, sort of. Types have <em>kinds</em>.</p>
<div class="gatsby-highlight" data-language="haskell"><pre class="language-haskell"><code class="language-haskell">ghci&gt; :Kind Maybe
Maybe :: * -&gt; *</code></pre></div>
<p>What? What is <strong>*</strong>? <strong>*</strong> is the <em>kind</em> of types which have values. At its core, what this means is that the <em>kind</em> of <strong>Maybe</strong> accepts a type that has values. This is called <a href="https://www.stephanboyer.com/post/115/higher-rank-and-higher-kinded-types">higher kinded polymorphism</a>. As a generalization, higher-minded polymorphism is a method for abstracting types from values. It's analogous to how functions already abstract values from values.</p>
<div class="gatsby-highlight" data-language="haskell"><pre class="language-haskell"><code class="language-haskell">Data HigherKinded a b
 = Bare b
 | Wrapped (a b)</code></pre></div>
<p>Haskell's kind inference is fairly simple and straightforward. If you scroll back up to the top, you'll see the similarities between it and Haskell's type inference. This is because when we declare a type that applies a function <strong>a</strong> to a value <strong>b</strong>, Haskell knows that <strong>a</strong> must have the kind <code class="language-text">* -&gt; *</code>, and a type of <em>kind</em> <strong>*</strong> that returns a type of <em>kind</em> <strong>*</strong>. In English, this means that <code class="language-text">HigherKinded</code> accepts two types: the first of which is a function that does not have values itself, but when provided with a type that <em>does</em> have values, those values are then applied to the function. The second argument is simply a type that have values. Finally, it returns a type that can have ordinary values. *Think about how the <strong>Maybe</strong> type's kind would be defined in this way.*</p>
<h3>Dynamically Kinded Programming</h3>
<p>Moving on from higher kinded types, let's take a moment to discuss its lesser-known counterpart. The easiest way to discuss dynamically kinded types is through example.</p>
<div class="gatsby-highlight" data-language="haskell"><pre class="language-haskell"><code class="language-haskell">ghci&gt; data Void
ghci&gt; :kind Void
Void :: *</code></pre></div>
<p>When we declare a type <strong>Void</strong> and a subsequently check for that type's kind, we're greeted by <strong>*</strong>. Are you surprised? In the same way that you can productively program at the value level with dynamic types as you learn how to do when building a foundation in functional programming, you can also program at the type level with dynamic kinds.</p>
<p><em>At its core, that's what <strong>*</strong> represents</em>.</p>
<p>Now that you understand that, we can start encoding our first type level numbers. As an example, we can start by defining types for <a href="https://en.wikipedia.org/wiki/Peano_axioms">Peano natural numbers</a>. Defining our numbers will be as easy as defining two data constructors, <strong>Zero</strong> and the <strong>Succ</strong> (Successor) of some natural number.</p>
<div class="gatsby-highlight" data-language="haskell"><pre class="language-haskell"><code class="language-haskell">data Zero
data Succ a

type One = Succ Zero
type Two = Succ One
type Three = Succ Two
type Four = Succ (Succ (Succ (Succ Zero)))</code></pre></div>
<p>As you can see from the example above, declaring our number types is as easy as using functional application with the two data constructors that we defined above. When defining subsequent types such as <strong>Two</strong>, or <strong>Three</strong>, you can observe that we can either reference already defined types to define the new type, or we can use functional application as in the case of the <strong>Four</strong> type. However, this method isn't without its caveats. There's nothing preventing us from declaring a type with <code class="language-text">type One = Succ Bool</code>, which doesn't make any sense. In order to get around this, we'll need to introduce more kinds than the mere <strong>*</strong> kind that we've been dealing with until this point.</p>
<h3>Data Kinds</h3>
<p>The <code class="language-text">DataKinds</code> GHC extension allows us to extend the functionality of data constructors into type constructors. As a consequence this also extends the type constructors into kind constructors. Just as with the above information, the best way to convey what this extension allows you to do is through example.</p>
<div class="gatsby-highlight" data-language="haskell"><pre class="language-haskell"><code class="language-haskell">{-# LANGUAGE DataKinds #-}

data Nat = Zero | Succ Nat</code></pre></div>
<p>The definition above declares a new type <strong>Nat</strong> that consists of two value constructors, <strong>Zero</strong> and <strong>Succ</strong>. The <code class="language-text">DataKinds</code> extension introduced a new kind <strong>Nat</strong>, which exists in a separate namespace. In addition to this, we also get two new types, <strong>'Zero</strong>, which has the kind of <strong>Nat</strong>, and <strong>'Succ</strong>, which accepts a type of kind <strong>Nat</strong>.</p>
<div class="gatsby-highlight" data-language="haskell"><pre class="language-haskell"><code class="language-haskell">ghci&gt; :kind &#39;Zero
&#39;Zero :: Nat
ghci&gt; :kind &#39;Succ
&#39;Succ :: Nat -&gt; Nat</code></pre></div>
<p>Fairly simple, right? And as an aside, If we ever need to promote something a level up, we prefix the name with an apostrophe: <strong>'</strong>. Where it can be ambiguous, the <strong>'</strong> is used to disambiguate. Otherwise, Haskell will infer which you mean. After all, if we check the types, they should look the same!</p>
<div class="gatsby-highlight" data-language="haskell"><pre class="language-haskell"><code class="language-haskell">ghci&gt; :type Zero
Zero :: Nat
ghci&gt; :type Succ
Succ :: Nat -&gt; Nat</code></pre></div>
<p>And that's all that there is to it when it comes to extending our type and kind constructors. We now have the ability to architect pretty basic types and kinds. However, in order to actually use them, though, we'll need to dive in a little deeper.</p>
<p><em>In the next article, part two of this series on type level programming, we'll discuss how to implement these types with GADTs, Vectors, Type Families, and more.</em></p></div><div class="post__Comments-sc-48ualj-0 cMeLzD"></div></div></div></div></div></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.page={"componentChunkName":"component---src-templates-post-js","jsonName":"2018-04-10-type-level-programming-part-1-ecf","path":"/2018/04/10/type-level-programming-part-1"};window.dataPath="284/path---2018-04-10-type-level-programming-part-1-ecf-21f-bTp74uLXUHKFYeP8zVSoHkU1Vq0";/*]]>*/</script><script src="/webpack-runtime-b145ddd9c3709fa1e1bf.js" async=""></script><script src="/0-288ed6b0962aa8bad9c0.js" async=""></script><script src="/1-5a707e09b8f49b2b05ae.js" async=""></script><script src="/app-40ef773447651335202c.js" async=""></script><script src="/component---src-templates-post-js-5142991cc9c82a431204.js" async=""></script></body></html>